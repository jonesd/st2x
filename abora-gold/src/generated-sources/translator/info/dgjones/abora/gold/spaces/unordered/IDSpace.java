/*
 * Abora-Gold
 * Part of the Abora hypertext project: http://www.abora.org
 * Copyright 2003, 2005 David G Jones
 * 
 * Translated from Udanax-Gold source code: http://www.udanax.com
 * Copyright 1979-1999 Udanax.com. All rights reserved
 */

package info.dgjones.abora.gold.spaces.unordered;

import info.dgjones.abora.gold.be.basic.BeGrandMap;
import info.dgjones.abora.gold.be.basic.ID;
import info.dgjones.abora.gold.cobbler.Cookbook;
import info.dgjones.abora.gold.collection.basic.PrimIntArray;
import info.dgjones.abora.gold.collection.basic.UInt8Array;
import info.dgjones.abora.gold.collection.tables.MuTable;
import info.dgjones.abora.gold.counter.Counter;
import info.dgjones.abora.gold.filter.Filter;
import info.dgjones.abora.gold.filter.FilterSpace;
import info.dgjones.abora.gold.id.IDRegion;
import info.dgjones.abora.gold.java.AboraSupport;
import info.dgjones.abora.gold.java.HashHelper;
import info.dgjones.abora.gold.java.exception.AboraRuntimeException;
import info.dgjones.abora.gold.java.exception.PasseException;
import info.dgjones.abora.gold.java.missing.smalltalk.Set;
import info.dgjones.abora.gold.nkernel.FeServer;
import info.dgjones.abora.gold.spaces.basic.CoordinateSpace;
import info.dgjones.abora.gold.spaces.integers.IntegerRegion;
import info.dgjones.abora.gold.spaces.integers.IntegerSpace;
import info.dgjones.abora.gold.spaces.unordered.IDDsp;
import info.dgjones.abora.gold.spaces.unordered.IDSpace;
import info.dgjones.abora.gold.tumbler.IDUpOrder;
import info.dgjones.abora.gold.tumbler.Sequence;
import info.dgjones.abora.gold.tumbler.SequenceSpace;
import info.dgjones.abora.gold.urdi.WriteVariableArrayStream;
import info.dgjones.abora.gold.xcvr.Binary2XcvrMaker;
import info.dgjones.abora.gold.xcvr.Rcvr;
import info.dgjones.abora.gold.xcvr.SpecialistRcvr;
import info.dgjones.abora.gold.xcvr.SpecialistXmtr;
import info.dgjones.abora.gold.xcvr.TransferSpecialist;
import info.dgjones.abora.gold.xcvr.Xmtr;
import info.dgjones.abora.gold.xcvr.XnReadStream;
import info.dgjones.abora.gold.xpp.basic.Heaper;
import java.io.PrintWriter;

/**
 * A space of IDs, which can generate globally unique IDs.
 * Implementation note:
 * myBackend - the identifier of the Server which generated this space. If NULL, then it was
 * generated by the current Server (unless mySpaceNumber is -1, in which case it is the
 * single global IDSpace shared by all Servers.
 * mySpaceNumber - identifies which space this is. If -1, then it is the global ID space, and
 * myBackend must be NULL.
 */
public class IDSpace extends CoordinateSpace {

	protected Sequence myBackend;
	protected int mySpaceNumber;
	protected Counter myNewIDCounter;
/*
udanax-top.st:15081:
CoordinateSpace subclass: #IDSpace
	instanceVariableNames: '
		myBackend {Sequence | NULL}
		mySpaceNumber {IntegerVar}
		myNewIDCounter {Counter}'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Xanadu-Spaces-Unordered'!
*/
/*
udanax-top.st:15088:
IDSpace comment:
'A space of IDs, which can generate globally unique IDs.
Implementation note:
	myBackend - the identifier of the Server which generated this space. If NULL, then it was generated by the current Server (unless mySpaceNumber is -1, in which case it is the single global IDSpace shared by all Servers.
	mySpaceNumber - identifies which space this is. If -1, then it is the global ID space, and myBackend must be NULL.'!
*/
/*
udanax-top.st:15094:
(IDSpace getOrMakeCxxClassDescription)
	friends:
'friend IDSimpleStepper;
friend class BeGrandMap;
friend class IDTester;
friend class ID;
friend class IDRegion;';
	attributes: ((Set new) add: #PSEUDO.COPY; add: #CONCRETE; add: #ON.CLIENT; yourself)!
*/
/*
udanax-top.st:15282:
IDSpace class
	instanceVariableNames: ''!
*/
/*
udanax-top.st:15285:
(IDSpace getOrMakeCxxClassDescription)
	friends:
'friend IDSimpleStepper;
friend class BeGrandMap;
friend class IDTester;
friend class ID;
friend class IDRegion;';
	attributes: ((Set new) add: #PSEUDO.COPY; add: #CONCRETE; add: #ON.CLIENT; yourself)!
*/
public static void initializeClassAttributes() {
	AboraSupport.findAboraClass(IDSpace.class).setAttributes( new Set().add("PSEUDOCOPY").add("CONCRETE").add("ONCLIENT"));
/*

Generated during transformation: AddMethod
*/
}
/**
 * Essential. The Region of IDs in this space which might be genrated by the given Server
 */
public IDRegion iDsFromServer(Sequence identifier) {
	RaviNow.shouldImplement();
	return null;
/*
udanax-top.st:15105:IDSpace methodsFor: 'making'!
{IDRegion CLIENT} iDsFromServer: identifier {Sequence}
	"Essential. The Region of IDs in this space which might be genrated by the given Server"
	
	RaviNow shouldImplement.
	^NULL "fodder"!
*/
}
/**
 * Essential. A new ID guaranteed to be different from every other newID generated by this
 * IDSpace or any IDSpace isEqual to it, on any Server. (Although of course IDs generated
 * using this->oldID () may conflict if the right numbers happen to have been supplied.)
 */
public ID newID() {
	return ID.make(fetchIDSpace(), null, myNewIDCounter.increment());
/*
udanax-top.st:15111:IDSpace methodsFor: 'making'!
{ID CLIENT} newID
	"Essential. A new ID guaranteed to be different from every other newID generated by this IDSpace or any IDSpace isEqual to it, on any Server. (Although of course IDs generated using this->oldID () may conflict if the right numbers happen to have been supplied.)"
	
	^ID make: self fetchIDSpace
		with: NULL
		with: myNewIDCounter increment!
*/
}
/**
 * A region containing a finite number of globally unique IDs. See newID for uniqueness
 * guarantees.
 */
public IDRegion newIDs(int count) {
	return IDRegion.make(fetchIDSpace(), (IntegerRegion.integerExtent((myNewIDCounter.incrementBy(count)), count)), null, false);
/*
udanax-top.st:15118:IDSpace methodsFor: 'making'!
{IDRegion CLIENT} newIDs: count {IntegerVar}
	"A region containing a finite number of globally unique IDs. See newID for uniqueness guarantees."
	
	^IDRegion make: self fetchIDSpace
			with: (IntegerRegion
				integerExtent: (myNewIDCounter incrementBy: count)
				with: count)
			with: NULL
			with: false!
*/
}
/**
 * Essential. The Server which created this IDSpace
 */
public Sequence backend() {
	if (myBackend == null) {
		if (mySpaceNumber == -1) {
			return Sequence.zero();
		}
		else {
			return FeServer.identifier();
		}
	}
	return myBackend;
/*
udanax-top.st:15130:IDSpace methodsFor: 'private: for friends'!
{Sequence} backend
	"Essential. The Server which created this IDSpace"
	
	myBackend == NULL ifTrue:
		[mySpaceNumber = -1
			ifTrue: [^Sequence zero]
			ifFalse: [^FeServer identifier]].
	^myBackend!
*/
}
public Sequence fetchBackend() {
	return myBackend;
/*
udanax-top.st:15139:IDSpace methodsFor: 'private: for friends'!
{Sequence | NULL} fetchBackend
	^myBackend!
*/
}
/**
 * NULL if this is the global IDSpace, self otherwise
 */
public IDSpace fetchIDSpace() {
	if (myBackend == null && (mySpaceNumber == -1)) {
		return null;
	}
	else {
		return this;
	}
/*
udanax-top.st:15143:IDSpace methodsFor: 'private: for friends'!
{IDSpace | NULL} fetchIDSpace
	"NULL if this is the global IDSpace, self otherwise"
	
	(myBackend == NULL and: [mySpaceNumber = -1])
		ifTrue: [^NULL]
		ifFalse: [^self]!
*/
}
/**
 * Recreate a region of IDs from information that was stored outside the Server
 */
public IDRegion oldIDs(Sequence backend, IntegerRegion numbers) {
	if (backend.isZero()) {
		if (numbers.intersects((IntegerRegion.after(0)))) {
			throw new AboraRuntimeException(AboraRuntimeException.INVALID_REQUEST);
		}
		else {
			return IDRegion.make(fetchIDSpace(), numbers, null, false);
		}
	}
	else {
		MuTable table;
		if ( ! (numbers.isSubsetOf((IntegerRegion.after(0))))) {
			throw new AboraRuntimeException(AboraRuntimeException.INVALID_REQUEST);
		}
		if (backend.isEqual(FeServer.identifier())) {
			return IDRegion.make(fetchIDSpace(), numbers, null, false);
		}
		table = MuTable.make(SequenceSpace.make());
		table.store(backend, numbers);
		return IDRegion.make(fetchIDSpace(), IntegerRegion.make(), table.asImmuTable(), false);
	}
/*
udanax-top.st:15150:IDSpace methodsFor: 'private: for friends'!
{IDRegion} oldIDs: backend {Sequence} with: numbers {IntegerRegion}
	"Recreate a region of IDs from information that was stored outside the Server"
	
	backend isZero ifTrue:
		[(numbers intersects: (IntegerRegion after: IntegerVarZero))
			ifTrue: [Heaper BLAST: #InvalidRequest]
			ifFalse: [^IDRegion make: self fetchIDSpace
				with: numbers with: NULL with: false]]
	ifFalse:
		[ | table {MuTable} |
		(numbers isSubsetOf: (IntegerRegion after: IntegerVarZero))
			ifFalse: [Heaper BLAST: #InvalidRequest].
		(backend isEqual: FeServer identifier)
			ifTrue: [^IDRegion make: self fetchIDSpace
				with: numbers with: NULL with: false].
		table := MuTable make: SequenceSpace make.
		table at: backend store: numbers.
		^IDRegion make: self fetchIDSpace
				with: IntegerRegion make
				with: table asImmuTable
				with: false].
	^NULL "fodder"!
*/
}
/**
 * Essential. Identifies this particular space among all those generated by the same Server.
 */
public int spaceNumber() {
	return mySpaceNumber;
/*
udanax-top.st:15173:IDSpace methodsFor: 'private: for friends'!
{IntegerVar} spaceNumber
	"Essential. Identifies this particular space among all those generated by the same Server."
	
	^mySpaceNumber!
*/
}
public IDSpace(Sequence backend, int number, Counter counter) {
	super();
	myBackend = backend;
	mySpaceNumber = number;
	finishCreation();
	myNewIDCounter = counter;
/*
udanax-top.st:15180:IDSpace methodsFor: 'private: create'!
create: backend {Sequence | NULL} with: number {IntegerVar} with: counter {Counter}
	super create.
	myBackend := backend.
	mySpaceNumber := number.
	self finishCreation.
	myNewIDCounter := counter!
*/
}
public void finishCreation() {
	IDSpace myself;
	if (myBackend == null && (mySpaceNumber == -1)) {
		myself = null;
	}
	else {
		myself = this;
	}
	finishCreate((IDRegion.usingx(myself, ((IntegerRegion) IntegerSpace.make().emptyRegion()), null, false)), (IDRegion.usingx(myself, ((IntegerRegion) IntegerSpace.make().fullRegion()), null, true)), (IDDsp.make(this)), (IDUpOrder.make(this)), null);
/*
udanax-top.st:15188:IDSpace methodsFor: 'private: create'!
{void} finishCreation
	
	| myself {IDSpace} |
	(myBackend == NULL and: [mySpaceNumber = -1])
		ifTrue: [myself := NULL]
		ifFalse: [myself := self].
	self finishCreate: (IDRegion
			usingx: myself with: (IntegerSpace make emptyRegion cast: IntegerRegion) with: NULL with: false)
		with: (IDRegion
			usingx: myself with: (IntegerSpace make fullRegion cast: IntegerRegion) with: NULL with: true)
		with: (IDDsp make: self)
		with: (IDUpOrder make: self)
		with: NULL!
*/
}
public int actualHashForEqual() {
	if (myBackend == null) {
		return HashHelper.hashForEqual(mySpaceNumber) ^ getCategory().hashForEqual();
	}
	else {
		return (myBackend.hashForEqual() ^ HashHelper.hashForEqual(mySpaceNumber)) ^ getCategory().hashForEqual();
	}
/*
udanax-top.st:15204:IDSpace methodsFor: 'testing'!
{UInt32} actualHashForEqual
	myBackend == NULL
		ifTrue: [^mySpaceNumber DOThashForEqual
			bitXor: self getCategory hashForEqual]
		ifFalse: [^(myBackend hashForEqual
			bitXor: mySpaceNumber DOThashForEqual)
			bitXor: self getCategory hashForEqual]!
*/
}
public boolean isEqual(Heaper other) {
	if (other instanceof IDSpace) {
		IDSpace space = (IDSpace) other;
		return this == space || (mySpaceNumber == space.spaceNumber() && ((myBackend == null && (space.fetchBackend() == null)) || (myBackend != null && (space.fetchBackend() != null && (myBackend.isEqual(space.fetchBackend()))))));
	}
	else {
		return false;
	}
/*
udanax-top.st:15213:IDSpace methodsFor: 'testing'!
{BooleanVar} isEqual: other {Heaper}
	other cast: IDSpace into: [ :space |
		^self == space
			or: [mySpaceNumber = space spaceNumber
				and: [(myBackend == NULL 
						and: [space fetchBackend == NULL])
					or: [myBackend ~~ NULL
						and: [space fetchBackend ~~ NULL
						and: [myBackend isEqual: space fetchBackend]]]]]]
	others:
		[^false].
	^false "fodder"!
*/
}
public void printOn(PrintWriter oo) {
	oo.print(getAboraClass().name());
	oo.print("(");
	if (fetchIDSpace() == null) {
		oo.print("!0");
	}
	else {
		oo.print(backend());
		oo.print(".");
		oo.print(mySpaceNumber);
	}
	oo.print(")");
/*
udanax-top.st:15229:IDSpace methodsFor: 'printing'!
{void} printOn: oo {ostream reference}
	oo << self getCategory name << '('.
	self fetchIDSpace == NULL
		ifTrue: [oo << '!!0']
		ifFalse: [oo << self backend << '.' << mySpaceNumber].
	oo << ')'!
*/
}
/**
 * Essential. Produce an array which can be handed to Server::importIDSpace on any Server to
 * get back the same IDSpace
 */
public UInt8Array export() {
	SpecialistXmtr xmtr;
	WriteVariableArrayStream result;
	result = WriteVariableArrayStream.make(200);
	xmtr = Binary2XcvrMaker.make().makeXmtr((TransferSpecialist.make(Cookbook.make())), result);
	ID.exportSequence(xmtr, backend());
	xmtr.sendIntegerVar(spaceNumber());
	return result.array();
/*
udanax-top.st:15239:IDSpace methodsFor: 'accessing'!
{UInt8Array CLIENT} export
	"Essential. Produce an array which can be handed to Server::importIDSpace on any Server to get back the same IDSpace"
	
	| xmtr {SpecialistXmtr} result {WriteVariableArrayStream} |
	result := WriteVariableArrayStream make: 200.
	xmtr := Binary2XcvrMaker make
		makeXmtr: (TransferSpecialist make: Cookbook make)
		with: result.
	ID exportSequence: xmtr with: self backend.
	xmtr sendIntegerVar: self spaceNumber.
	^result array!
*/
}
/**
 * A Sequence uniquely identifying this IDSpace, so that
 * FeServer::current ()->oldIDSpace (this->identifier ())
 * ->isEqual (this)
 */
public Sequence identifier() {
	Ravi.thingToDo();
	/* get rid of this message and its clients */
	return backend().withLast(mySpaceNumber);
/*
udanax-top.st:15253:IDSpace methodsFor: 'obsolete:'!
{Sequence} identifier
	"A Sequence uniquely identifying this IDSpace, so that
		FeServer::current ()->oldIDSpace (this->identifier ())
			->isEqual (this)"
	
	Ravi thingToDo. "get rid of this message and its clients"
	^self backend withLast: mySpaceNumber!
*/
}
public void sendIDSpaceTo(Xmtr xmtr) {
	xmtr.sendHeaper(myBackend);
	xmtr.sendIntegerVar(mySpaceNumber);
	xmtr.sendHeaper(myNewIDCounter);
/*
udanax-top.st:15263:IDSpace methodsFor: 'hooks:'!
{void SEND.HOOK} sendIDSpaceTo: xmtr {Xmtr}
	xmtr sendHeaper: myBackend.
	xmtr sendIntegerVar: mySpaceNumber.
	xmtr sendHeaper: myNewIDCounter.!
*/
}
/**
 * Recreate an ID from its identifier.
 * @deprecated
 */
public ID oldID(Sequence identifier) {
	throw new PasseException();
/*
udanax-top.st:15270:IDSpace methodsFor: 'smalltalk: passe'!
{ID} oldID: identifier {Sequence}
	"Recreate an ID from its identifier."
	
	self passe.!
*/
}
public void sendSelfTo(Xmtr xmtr) {
	sendIDSpaceTo(xmtr);
/*
udanax-top.st:15277:IDSpace methodsFor: 'generated:'!
{void} sendSelfTo: xmtr {Xmtr}
	
	self sendIDSpaceTo: xmtr.!
*/
}
/**
 * Return the global ID space.
 */
public static IDSpace global() {
	return ((BeGrandMap) CurrentGrandMap.fluidGet()).globalIDSpace();
/*
udanax-top.st:15296:IDSpace class methodsFor: 'creation'!
{IDSpace CLIENT} global
	"Return the global ID space."
	
	^CurrentGrandMap fluidGet globalIDSpace!
*/
}
/**
 * Essential. Take some information describing an IDSpace and create the IDSpace it was
 * exported from.
 */
public static IDSpace importx(PrimIntArray data) {
	SpecialistRcvr rcvr;
	Sequence backend;
	int number;
	rcvr = Binary2XcvrMaker.make().makeRcvr((TransferSpecialist.make(Cookbook.make())), (XnReadStream.make(((UInt8Array) data))));
	backend = ID.importSequence(rcvr);
	number = rcvr.receiveIntegerVar();
	return make(backend, number);
/*
udanax-top.st:15301:IDSpace class methodsFor: 'creation'!
{IDSpace CLIENT} import: data {PrimIntArray}
	"Essential. Take some information describing an IDSpace and create the IDSpace it was exported from."
	
	| rcvr {SpecialistRcvr} backend {Sequence} number {IntegerVar} |
	rcvr := Binary2XcvrMaker make
		makeRcvr: (TransferSpecialist make: Cookbook make)
		with: (XnReadStream make: (data cast: UInt8Array)).
	backend := ID importSequence: rcvr.
	number := rcvr receiveIntegerVar.
	^self make: backend with: number!
*/
}
/**
 * Essential. Create a new globally unique space of IDs
 */
public static IDSpace unique() {
	return ((BeGrandMap) CurrentGrandMap.fluidGet()).newIDSpace();
/*
udanax-top.st:15312:IDSpace class methodsFor: 'creation'!
{IDSpace CLIENT} unique
	"Essential. Create a new globally unique space of IDs"
	
	^CurrentGrandMap fluidGet newIDSpace!
*/
}
public static IDSpace make(Sequence identifier, int number) {
	return make(identifier, number, (((BeGrandMap) CurrentGrandMap.fluidGet()).getOrMakeIDCounter(identifier, number)));
/*
udanax-top.st:15319:IDSpace class methodsFor: 'private: pseudo constructors'!
make: identifier {Sequence | NULL} with: number {IntegerVar}
	^self make: identifier with: number with: (CurrentGrandMap fluidGet
		getOrMakeIDCounter: identifier with: number)!
*/
}
public static IDSpace make(Sequence identifier, int number, Counter counter) {
	BeGrandMap cgm;
	cgm = ((BeGrandMap) CurrentGrandMap.fluidFetch());
	if (identifier != null && (identifier.isZero() || (cgm != null && (identifier.isEqual(cgm.identifier()))))) {
		return new IDSpace(null, number, counter);
	}
	return new IDSpace(identifier, number, counter);
/*
udanax-top.st:15324:IDSpace class methodsFor: 'private: pseudo constructors'!
make: identifier {Sequence | NULL} with: number {IntegerVar} with: counter {Counter}
	| cgm {BeGrandMap} |
	cgm := CurrentGrandMap fluidFetch.
	(identifier ~~ NULL and: [identifier isZero
			or: [cgm ~~ NULL and: [identifier isEqual: cgm identifier]]])
		ifTrue: [^self create: NULL with: number with: counter].
	^self create: identifier with: number with: counter!
*/
}
/**
 * The coordinate space of filters on IDRegions.
 * @deprecated
 */
public static FilterSpace iDFilterSpace() {
	throw new PasseException();
/*
udanax-top.st:15335:IDSpace class methodsFor: 'smalltalk: passe'!
{FilterSpace of: IDSpace} iDFilterSpace
	"The coordinate space of filters on IDRegions."
	self passe!
*/
}
/**
 * @deprecated
 */
public static Filter openIDFilter() {
	throw new PasseException();
/*
udanax-top.st:15339:IDSpace class methodsFor: 'smalltalk: passe'!
{Filter of: IDSpace} openIDFilter
	self passe.!
*/
}
public static Heaper makeRcvr(Rcvr rcvr) {
	Heaper memory;
	Sequence backend;
	int space;
	Counter idCounter;
	Someone.thingToDo();
	/* Should intern someday */
	memory = ((SpecialistRcvr) rcvr).makeIbid(AboraSupport.findCategory(IDSpace.class));
	backend = (Sequence) rcvr.receiveHeaper();
	space = rcvr.receiveIntegerVar();
	idCounter = (Counter) rcvr.receiveHeaper();
	return 
	/* TODO newBecome */
	new IDSpace(backend, space, idCounter);
/*
udanax-top.st:15344:IDSpace class methodsFor: 'rcvr pseudo constructors'!
{Heaper} make.Rcvr: rcvr {Rcvr} 
	| memory {Heaper} backend {Sequence} space {IntegerVar} idCounter {Counter} |
	self thingToDo. "Should intern someday"
	memory _ (rcvr cast: SpecialistRcvr) makeIbid: IDSpace.
	backend _ rcvr receiveHeaper cast: Sequence.
	space _ rcvr receiveIntegerVar.
	idCounter _ rcvr receiveHeaper cast: Counter.
	^(IDSpace new.Become: memory)
		create: backend
		with: space
		with: idCounter!
*/
}
/**
 * {UInt8Array CLIENT} export
 * {IDRegion CLIENT} iDsFromServer: identifier {Sequence}
 * {ID CLIENT} newID
 * {IDRegion CLIENT} newIDs: count {IntegerVar}
 */
public static void infostProtocol() {
/*
udanax-top.st:15358:IDSpace class methodsFor: 'smalltalk: system'!
info.stProtocol
"{UInt8Array CLIENT} export
{IDRegion CLIENT} iDsFromServer: identifier {Sequence}
{ID CLIENT} newID
{IDRegion CLIENT} newIDs: count {IntegerVar}
"!
*/
}
public IDSpace() {
/*

Generated during transformation
*/
}
public IDSpace(Rcvr receiver) {
	super(receiver);
/*

Generated during transformation
*/
}
}
