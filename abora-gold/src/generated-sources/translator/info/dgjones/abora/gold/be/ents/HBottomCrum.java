/*
 * Abora-Gold
 * Part of the Abora hypertext project: http://www.abora.org
 * Copyright 2003, 2005 David G Jones
 * 
 * Translated from Udanax-Gold source code: http://www.udanax.com
 * Copyright 1979-1999 Udanax.com. All rights reserved
 */

package info.dgjones.abora.gold.be.ents;

import info.dgjones.abora.gold.backrec.ResultRecorder;
import info.dgjones.abora.gold.be.basic.BeEdition;
import info.dgjones.abora.gold.be.canopy.BertCrum;
import info.dgjones.abora.gold.be.canopy.PropFinder;
import info.dgjones.abora.gold.be.canopy.prop.BertProp;
import info.dgjones.abora.gold.be.canopy.prop.Prop;
import info.dgjones.abora.gold.be.ents.HBottomCrum;
import info.dgjones.abora.gold.be.ents.HistoryCrum;
import info.dgjones.abora.gold.collection.cache.HashSetCache;
import info.dgjones.abora.gold.collection.sets.ImmuSet;
import info.dgjones.abora.gold.collection.sets.MuSet;
import info.dgjones.abora.gold.collection.steppers.Stepper;
import info.dgjones.abora.gold.fossil.RecorderFossil;
import info.dgjones.abora.gold.java.AboraSupport;
import info.dgjones.abora.gold.java.exception.PasseException;
import info.dgjones.abora.gold.java.missing.smalltalk.Set;
import info.dgjones.abora.gold.nkernel.FeEdition;
import info.dgjones.abora.gold.props.PropChange;
import info.dgjones.abora.gold.spaces.basic.Mapping;
import info.dgjones.abora.gold.spaces.basic.XnRegion;
import info.dgjones.abora.gold.traces.TracePosition;
import info.dgjones.abora.gold.turtle.AgendaItem;
import info.dgjones.abora.gold.xcvr.Rcvr;
import info.dgjones.abora.gold.xcvr.Xmtr;
import java.io.PrintWriter;

public class HBottomCrum extends HistoryCrum {

	protected TracePosition myTrace;
	protected BertCrum myBertCrum;
	protected MuSet myEditions;
/*
udanax-top.st:27313:
HistoryCrum subclass: #HBottomCrum
	instanceVariableNames: '
		myTrace {TracePosition}
		myBertCrum {BertCrum}
		myEditions {MuSet of: BeEditions}'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Xanadu-Be-Ents'!
*/
/*
udanax-top.st:27320:
(HBottomCrum getOrMakeCxxClassDescription)
	attributes: ((Set new) add: #CONCRETE; add: #COPY; yourself)!
*/
/*
udanax-top.st:27480:
HBottomCrum class
	instanceVariableNames: ''!
*/
/*
udanax-top.st:27483:
(HBottomCrum getOrMakeCxxClassDescription)
	attributes: ((Set new) add: #CONCRETE; add: #COPY; yourself)!
*/
public static void initializeClassAttributes() {
	AboraSupport.findAboraClass(HBottomCrum.class).setAttributes( new Set().add("CONCRETE").add("COPY"));
/*

Generated during transformation: AddMethod
*/
}
/**
 * Return true if there are stamps that
 * point at this orgl.
 */
public boolean hasRefs() {
	return ! myEditions.isEmpty();
/*
udanax-top.st:27325:HBottomCrum methodsFor: 'testing'!
{BooleanVar} hasRefs
	"Return true if there are stamps that
	 point at this orgl."
	^myEditions isEmpty not!
*/
}
/**
 * Return true if the receiver can backfollow to trace.
 */
public boolean inTrace(TracePosition trace) {
	Dean.hack();
	/* The following grotesque hack (myEdition isEmpty not) is so that intermediate orglRoots generated by copy and combine are not considered for version comparison.  The proper thing to do is make those operations destroy their intermediate results. */
	return (myTrace) == trace && ( ! myEditions.isEmpty());
/*
udanax-top.st:27331:HBottomCrum methodsFor: 'testing'!
{Boolean} inTrace: trace {TracePosition}
	"Return true if the receiver can backfollow to trace."
	Dean hack.  "The following grotesque hack (myEdition isEmpty not) is so that intermediate orglRoots generated by copy and combine are not considered for version comparison.  The proper thing to do is make those operations destroy their intermediate results."
	^(myTrace basicCast: Heaper star) == trace and: [myEditions isEmpty not]!
*/
}
/**
 * Return true if their are no upward pointers.  This is used
 * by OParts to determine if they can be forgotten.
 */
public boolean isEmpty() {
	return myEditions.isEmpty();
/*
udanax-top.st:27337:HBottomCrum methodsFor: 'testing'!
{BooleanVar} isEmpty
	"Return true if their are no upward pointers.  This is used
	 by OParts to determine if they can be forgotten."
	
	^myEditions isEmpty!
*/
}
/**
 * If bertCrum is leafward of newBCrum then change it and return true,
 * otherwise return false.
 */
public boolean propagateBCrum(BertCrum newBCrum) {
	if (myBertCrum.isLE(newBCrum)) {
		return false;
	}
	else {
		myBertCrum = newBCrum;
		return true;
	}
/*
udanax-top.st:27343:HBottomCrum methodsFor: 'testing'!
{Boolean} propagateBCrum: newBCrum {BertCrum} 
	"If bertCrum is leafward of newBCrum then change it and return true, 
	otherwise return false."
	(myBertCrum isLE: newBCrum)
		ifTrue: [^false]
		ifFalse: 
			[myBertCrum _ newBCrum.
			^true]!
*/
}
public TracePosition hCut() {
	return myTrace;
/*
udanax-top.st:27355:HBottomCrum methodsFor: 'accessing'!
{TracePosition} hCut
	^myTrace!
*/
}
/**
 * return the mapping into the domain space of the given trace
 */
public Mapping mappingTo(TracePosition trace, Mapping initial) {
	if (inTrace(trace)) {
		return initial;
	}
	else {
		return Mapping.make(initial.coordinateSpace(), initial.rangeSpace());
	}
/*
udanax-top.st:27358:HBottomCrum methodsFor: 'accessing'!
{Mapping} mappingTo: trace {TracePosition} with: initial {Mapping}
	"return the mapping into the domain space of the given trace"
	(self inTrace: trace)
		ifTrue: [^initial]
		ifFalse: [^Mapping make: initial coordinateSpace with: initial rangeSpace]!
*/
}
public ImmuSet oParents() {
	return ImmuSet.make();
/*
udanax-top.st:27364:HBottomCrum methodsFor: 'accessing'!
{ImmuSet of: OPart} oParents
	^ImmuSet make!
*/
}
public void actualDelayedStoreBackfollow(PropFinder finder, RecorderFossil fossil, ResultRecorder recorder, HashSetCache hCrumCache) {
	if ( ! myEditions.isEmpty() && (finder.doesPass(myBertCrum))) {
		Stepper stomper = myEditions.stepper();
		for (; stomper.hasValue(); stomper.step()) {
			BeEdition edition = (BeEdition) stomper.fetch();
			if (edition == null) {
				continue ;
			}
			recorder.delayedStoreBackfollow(edition, finder, fossil, hCrumCache);
		}
		stomper.destroy();
	}
/*
udanax-top.st:27369:HBottomCrum methodsFor: 'filtering'!
{void} actualDelayedStoreBackfollow: finder {PropFinder} 
	with: fossil {RecorderFossil}
	with: recorder {ResultRecorder}
	with: hCrumCache {HashSetCache of: HistoryCrum}
	(myEditions isEmpty not and: [finder doesPass: myBertCrum]) ifTrue:
		[myEditions stepper forEach: [:edition {BeEdition} | 
			recorder delayedStoreBackfollow: edition
				with: finder
				with: fossil
				with: hCrumCache]]!
*/
}
public boolean anyPasses(PropFinder finder) {
	if (finder.doesPass(myBertCrum)) {
		Stepper stomper = myEditions.stepper();
		for (; stomper.hasValue(); stomper.step()) {
			BeEdition edition = (BeEdition) stomper.fetch();
			if (edition == null) {
				continue ;
			}
			if (edition.anyPasses(finder)) {
				return true;
			}
		}
		stomper.destroy();
	}
	return false;
/*
udanax-top.st:27381:HBottomCrum methodsFor: 'filtering'!
{BooleanVar} anyPasses: finder {PropFinder}
	(finder doesPass: myBertCrum) ifTrue:
		[myEditions stepper forEach: [:edition {BeEdition} |
			(edition anyPasses: finder)
				ifTrue: [^true]]].
	^false!
*/
}
public BertCrum bertCrum() {
	return myBertCrum;
/*
udanax-top.st:27388:HBottomCrum methodsFor: 'filtering'!
{BertCrum} bertCrum
	^myBertCrum!
*/
}
public void introduceEdition(BeEdition edition) {
	myEditions.introduce(edition);
	(propChanger(PropChange.bertPropChange())).schedule();
/*
udanax-top.st:27391:HBottomCrum methodsFor: 'filtering'!
{void} introduceEdition: edition {BeEdition}
	myEditions introduce: edition.
	(self propChanger: PropChange bertPropChange) schedule!
*/
}
/**
 * NOTE: The AgendaItem returned is not yet scheduled.  Doing so is up to my caller.
 */
public AgendaItem propChanger(PropChange change) {
	Prop newProp;
	newProp = BertProp.make();
	Stepper stomper = myEditions.stepper();
	for (; stomper.hasValue(); stomper.step()) {
		BeEdition edition = (BeEdition) stomper.fetch();
		if (edition == null) {
			continue ;
		}
		newProp = change.with(newProp, edition.prop());
	}
	stomper.destroy();
	return myBertCrum.propChanger(change, newProp);
/*
udanax-top.st:27396:HBottomCrum methodsFor: 'filtering'!
{AgendaItem} propChanger: change {PropChange}
	"NOTE: The AgendaItem returned is not yet scheduled.  Doing so is up to my caller."
	| newProp {Prop} |
	newProp _ BertProp make.
	myEditions stepper forEach: [:edition {BeEdition} |
		newProp _ change with: newProp with: edition prop].
	^myBertCrum propChanger: change with: newProp!
*/
}
public void removeEdition(BeEdition edition) {
	myEditions.remove(edition);
	(propChanger(PropChange.bertPropChange())).schedule();
/*
udanax-top.st:27405:HBottomCrum methodsFor: 'filtering'!
{void} removeEdition: edition {BeEdition}
	myEditions remove: edition.
	(self propChanger: PropChange bertPropChange) schedule!
*/
}
public void ringDetectors(FeEdition edition) {
	if (bertCrum().isSensorWaiting()) {
		Stepper stomper = myEditions.stepper();
		for (; stomper.hasValue(); stomper.step()) {
			BeEdition ed = (BeEdition) stomper.fetch();
			if (ed == null) {
				continue ;
			}
			ed.ringDetectors(edition);
		}
		stomper.destroy();
	}
/*
udanax-top.st:27410:HBottomCrum methodsFor: 'filtering'!
{void} ringDetectors: edition {FeEdition}
	self bertCrum isSensorWaiting ifTrue:
		[myEditions stepper forEach: [ :ed {BeEdition} |
			ed ringDetectors: edition]]!
*/
}
public HBottomCrum(TracePosition trace, BertCrum canopy) {
	super();
	myTrace = trace;
	myBertCrum = canopy;
	myBertCrum.addPointer(this);
	myEditions = MuSet.make();
/*
udanax-top.st:27418:HBottomCrum methodsFor: 'create'!
create: trace {TracePosition} with: canopy {BertCrum}
	super create.
	myTrace _ trace.
	myBertCrum _ canopy.
	myBertCrum addPointer: self.
	myEditions _ MuSet make!
*/
}
/*
udanax-top.st:27427:HBottomCrum methodsFor: 'smalltalk:'!
inspectOrgls
	(myStamps == NULL or: [myStamps isEmpty]) ifTrue:
		[^Transcript show: 'Nobody'; cr; endEntry].
	myStamps count == 1
		ifTrue: [myStamps stepper fetch orglRoot inspect]
		ifFalse: [(myStamps asOrderedCollection collect: [ :stamp | stamp orglRoot]) inspect]!
*/
public void printOn(PrintWriter aStream) {
	super.printOn(aStream);
	if (myEditions != null && ( ! myEditions.isEmpty())) {
		aStream.print('*');
	}
/*
udanax-top.st:27434:HBottomCrum methodsFor: 'smalltalk:'!
printOn: aStream
	super printOn: aStream.
	(myEditions ~~ NULL and: [myEditions isEmpty not]) ifTrue: [aStream nextPut: $*].!
*/
}
public void markChildren(int count) {
	myTrace.markInstances(count);
	myBertCrum.markInstances(count);
/*
udanax-top.st:27440:HBottomCrum methodsFor: 'smalltalk: gc'!
{void} markChildren: count {IntegerVar}
	myTrace markInstances: count.
	myBertCrum markInstances: count.!
*/
}
/**
 * @deprecated
 */
public void introduceStamp(BeEdition stamp) {
	throw new PasseException();
/*
udanax-top.st:27446:HBottomCrum methodsFor: 'smalltalk: passe'!
{void} introduceStamp: stamp {BeEdition}
	self passe!
*/
}
/**
 * @deprecated
 */
public void propChanged(PropChange change) {
	throw new PasseException();
/*
udanax-top.st:27450:HBottomCrum methodsFor: 'smalltalk: passe'!
{void} propChanged: change {PropChange}
	self passe!
*/
}
/**
 * @deprecated
 */
public void removeStamp(BeEdition stamp) {
	throw new PasseException();
/*
udanax-top.st:27454:HBottomCrum methodsFor: 'smalltalk: passe'!
{void} removeStamp: stamp {BeEdition}
	self passe!
*/
}
public XnRegion fetchRegionIn(BeEdition stamp, TracePosition hCut, XnRegion region) {
	Dean.shouldImplement();
	/* or else remove it again and get rid of polymorphs */
	return null;
/*
udanax-top.st:27460:HBottomCrum methodsFor: 'deferred accessing'!
{XnRegion} fetchRegionIn: stamp {BeEdition} with: hCut {TracePosition} with: region {XnRegion}
	Dean shouldImplement. "or else remove it again and get rid of polymorphs"
	^NULL "fodder"!
*/
}
public HBottomCrum(Rcvr receiver) {
	super(receiver);
	myTrace = (TracePosition) receiver.receiveHeaper();
	myBertCrum = (BertCrum) receiver.receiveHeaper();
	myEditions = (MuSet) receiver.receiveHeaper();
/*
udanax-top.st:27467:HBottomCrum methodsFor: 'generated:'!
create.Rcvr: receiver {Rcvr}
	super create.Rcvr: receiver.
	myTrace _ receiver receiveHeaper.
	myBertCrum _ receiver receiveHeaper.
	myEditions _ receiver receiveHeaper.!
*/
}
public void sendSelfTo(Xmtr xmtr) {
	super.sendSelfTo(xmtr);
	xmtr.sendHeaper(myTrace);
	xmtr.sendHeaper(myBertCrum);
	xmtr.sendHeaper(myEditions);
/*
udanax-top.st:27473:HBottomCrum methodsFor: 'generated:'!
{void} sendSelfTo: xmtr {Xmtr}
	super sendSelfTo: xmtr.
	xmtr sendHeaper: myTrace.
	xmtr sendHeaper: myBertCrum.
	xmtr sendHeaper: myEditions.!
*/
}
public static HBottomCrum make() {
	return new HBottomCrum(((TracePosition) CurrentTrace.fluidGet()), ((BertCrum) CurrentBertCrum.fluidGet()));
/*
udanax-top.st:27488:HBottomCrum class methodsFor: 'instance creation'!
{HBottomCrum} make
	[Ent] USES.
	^self create: CurrentTrace fluidGet with: CurrentBertCrum fluidGet!
*/
}
public HBottomCrum() {
/*

Generated during transformation
*/
}
}
