/*
 * Abora-Gold
 * Part of the Abora hypertext project: http://www.abora.org
 * Copyright 2003, 2005 David G Jones
 * 
 * Translated from Udanax-Gold source code: http://www.udanax.com
 * Copyright 1979-1999 Udanax.com. All rights reserved
 */

package info.dgjones.abora.gold.id;

import info.dgjones.abora.gold.be.basic.BeGrandMap;
import info.dgjones.abora.gold.be.basic.ID;
import info.dgjones.abora.gold.cobbler.Cookbook;
import info.dgjones.abora.gold.collection.basic.PrimIntArray;
import info.dgjones.abora.gold.collection.basic.UInt8Array;
import info.dgjones.abora.gold.collection.sets.ScruSet;
import info.dgjones.abora.gold.collection.sets.SetAccumulator;
import info.dgjones.abora.gold.collection.steppers.Stepper;
import info.dgjones.abora.gold.collection.steppers.TableStepper;
import info.dgjones.abora.gold.collection.tables.ImmuTable;
import info.dgjones.abora.gold.collection.tables.MuTable;
import info.dgjones.abora.gold.id.IDRegion;
import info.dgjones.abora.gold.id.IDSimpleStepper;
import info.dgjones.abora.gold.id.IDStepper;
import info.dgjones.abora.gold.java.AboraSupport;
import info.dgjones.abora.gold.java.exception.AboraRuntimeException;
import info.dgjones.abora.gold.java.exception.PasseException;
import info.dgjones.abora.gold.java.missing.smalltalk.Set;
import info.dgjones.abora.gold.nkernel.FeServer;
import info.dgjones.abora.gold.spaces.basic.CoordinateSpace;
import info.dgjones.abora.gold.spaces.basic.OrderSpec;
import info.dgjones.abora.gold.spaces.basic.Position;
import info.dgjones.abora.gold.spaces.basic.XnRegion;
import info.dgjones.abora.gold.spaces.integers.IntegerPos;
import info.dgjones.abora.gold.spaces.integers.IntegerRegion;
import info.dgjones.abora.gold.spaces.integers.IntegerSpace;
import info.dgjones.abora.gold.spaces.unordered.IDSpace;
import info.dgjones.abora.gold.tumbler.Sequence;
import info.dgjones.abora.gold.tumbler.SequenceRegion;
import info.dgjones.abora.gold.tumbler.SequenceSpace;
import info.dgjones.abora.gold.urdi.WriteVariableArrayStream;
import info.dgjones.abora.gold.xcvr.Binary2XcvrMaker;
import info.dgjones.abora.gold.xcvr.Rcvr;
import info.dgjones.abora.gold.xcvr.SpecialistRcvr;
import info.dgjones.abora.gold.xcvr.SpecialistXmtr;
import info.dgjones.abora.gold.xcvr.TransferSpecialist;
import info.dgjones.abora.gold.xcvr.Xmtr;
import info.dgjones.abora.gold.xcvr.XnReadStream;
import info.dgjones.abora.gold.xpp.basic.Heaper;
import java.io.PrintWriter;

/**
 * If mySpace is NULL, then it is assumed to be global IDSpace.
 * The non-negative part of myLocalIDs contains the number portion of all IDs in the region
 * that were generated by the current backend. The negative part contains all IDs which were
 * generated by the "global" backend.
 * If myImportedIDs is NULL, it is considered to be empty. If it is non-NULL, it must be
 * non-empty. It contains the numbers of all IDs in this region which were generated by other
 * backends. If an entry in the table could be omitted without effect, then it should be
 * omitted. (i.e. if myIncludesRest and the region is full, or myIncludesRest not and the
 * region is empty, then the entry should be omitted).
 * If myIncludesRest is true, then the region includes, in addition to those IDs explictly
 * listed in myLocalIDs and myImportedIDs, all ID generated by all other backends.
 */
public class IDRegion extends XnRegion {

	protected IDSpace mySpace;
	protected IntegerRegion myLocalIDs;
	protected ImmuTable myImportedIDs;
	protected boolean myIncludesRest;
	protected static IntegerRegion TheGlobalNumbers;
	protected static IntegerRegion TheLocalNumbers;
/*
udanax-top.st:67744:
XnRegion subclass: #IDRegion
	instanceVariableNames: '
		mySpace {IDSpace | NULL}
		myLocalIDs {IntegerRegion}
		myImportedIDs {ImmuTable | NULL of: Sequence and: IntegerRegion}
		myIncludesRest {BooleanVar}'
	classVariableNames: '
		TheGlobalNumbers {IntegerRegion} 
		TheLocalNumbers {IntegerRegion} '
	poolDictionaries: ''
	category: 'Xanadu-id'!
*/
/*
udanax-top.st:67754:
IDRegion comment:
'If mySpace is NULL, then it is assumed to be global IDSpace.
The non-negative part of myLocalIDs contains the number portion of all IDs in the region that were generated by the current backend. The negative part contains all IDs which were generated by the "global" backend.
If myImportedIDs is NULL, it is considered to be empty. If it is non-NULL, it must be non-empty. It contains the numbers of all IDs in this region which were generated by other backends. If an entry in the table could be omitted without effect, then it should be omitted. (i.e. if myIncludesRest and the region is full, or myIncludesRest not and the region is empty, then the entry should be omitted).
If myIncludesRest is true, then the region includes, in addition to those IDs explictly listed in myLocalIDs and myImportedIDs, all ID generated by all other backends.'!
*/
/*
udanax-top.st:67759:
(IDRegion getOrMakeCxxClassDescription)
	friends:
'friend class IDSpace;
friend class IDSimpleStepper;
friend class IDStepper;
friend class IDUpOrder;
';
	attributes: ((Set new) add: #CONCRETE; add: #ON.CLIENT; add: #COPY; yourself)!
*/
/*
udanax-top.st:68324:
IDRegion class
	instanceVariableNames: ''!
*/
/*
udanax-top.st:68327:
(IDRegion getOrMakeCxxClassDescription)
	friends:
'friend class IDSpace;
friend class IDSimpleStepper;
friend class IDStepper;
friend class IDUpOrder;
';
	attributes: ((Set new) add: #CONCRETE; add: #ON.CLIENT; add: #COPY; yourself)!
*/
public static void initializeClassAttributes() {
	AboraSupport.findAboraClass(IDRegion.class).setAttributes( new Set().add("CONCRETE").add("ONCLIENT").add("COPY"));
/*

Generated during transformation: AddMethod
*/
}
public XnRegion asSimpleRegion() {
	Ravi.thingToDo();
	/* make this more efficient and return fullRegion less often */
	if (isSimple()) {
		return this;
	}
	if (myImportedIDs != null) {
		return coordinateSpace().fullRegion();
	}
	return IDRegion.make(mySpace, ((IntegerRegion) myLocalIDs.asSimpleRegion()), null, myIncludesRest);
/*
udanax-top.st:67770:IDRegion methodsFor: 'accessing'!
{XnRegion} asSimpleRegion
	Ravi thingToDo. "make this more efficient and return fullRegion less often"
	self isSimple ifTrue:
		[^self].
	myImportedIDs ~~ NULL ifTrue:
		[^self coordinateSpace fullRegion].
	^IDRegion make: mySpace
		with: (myLocalIDs asSimpleRegion cast: IntegerRegion)
		with: NULL
		with: myIncludesRest!
*/
}
public CoordinateSpace coordinateSpace() {
	if (mySpace == null) {
		return IDSpace.global();
	}
	return mySpace;
/*
udanax-top.st:67782:IDRegion methodsFor: 'accessing'!
{CoordinateSpace} coordinateSpace
	mySpace == NULL
		ifTrue: [^IDSpace global].
	^mySpace!
*/
}
/**
 * Essential. Export the IDRegion in a form that can be used to recreate it with
 * IDRegion::import.
 */
public UInt8Array export() {
	SpecialistXmtr xmtr;
	WriteVariableArrayStream result;
	result = WriteVariableArrayStream.make(500);
	xmtr = Binary2XcvrMaker.make().makeXmtr((TransferSpecialist.make(Cookbook.make())), result);
	ID.exportSequence(xmtr, ((IDSpace) coordinateSpace()).backend());
	ID.exportIntegerRegion(xmtr, myLocalIDs);
	if (myImportedIDs == null) {
		xmtr.sendIntegerVar(0);
	}
	else {
		xmtr.sendIntegerVar(myImportedIDs.count());
		TableStepper stomper = myImportedIDs.stepper();
		for (; stomper.hasValue(); stomper.step()) {
			Sequence key = (Sequence) stomper.position();
			IntegerRegion value = (IntegerRegion) stomper.fetch();
			if (value == null) {
				continue ;
			}
			ID.exportSequence(xmtr, key);
			ID.exportIntegerRegion(xmtr, value);
		}
		stomper.destroy();
	}
	xmtr.sendBooleanVar(myIncludesRest);
	return result.array();
/*
udanax-top.st:67788:IDRegion methodsFor: 'accessing'!
{UInt8Array CLIENT} export
	"Essential. Export the IDRegion in a form that can be used to recreate it with IDRegion::import."
		
	| xmtr {SpecialistXmtr} result {WriteVariableArrayStream} |
	result := WriteVariableArrayStream make: 500.
	xmtr := Binary2XcvrMaker make
		makeXmtr: (TransferSpecialist make: Cookbook make)
		with: result.
	ID exportSequence: xmtr
		with: (self coordinateSpace cast: IDSpace) backend.
	ID exportIntegerRegion: xmtr with: myLocalIDs.
	myImportedIDs == NULL ifTrue:
		[xmtr sendIntegerVar: IntegerVarZero]
	ifFalse:
		[xmtr sendIntegerVar: myImportedIDs count.
		myImportedIDs stepper forPositions: [ :key {Sequence} :value {IntegerRegion} |
			ID exportSequence: xmtr with: key.
			ID exportIntegerRegion: xmtr with: value]].
	xmtr sendIntegerVar: myIncludesRest.
	^result array!
*/
}
public Position theOne() {
	if ( ! (myIncludesRest)) {
		if (myLocalIDs.isEmpty()) {
			if (myImportedIDs != null) {
				return ID.make(mySpace, ((Sequence) myImportedIDs.domain().theOne()), ((IntegerPos) ((IntegerRegion) myImportedIDs.theOne()).theOne()).asIntegerVar());
			}
		}
		else {
			if (myImportedIDs == null) {
				return ID.make(mySpace, null, ((IntegerPos) myLocalIDs.theOne()).asIntegerVar());
			}
		}
	}
	throw new AboraRuntimeException(AboraRuntimeException.NOT_ONE_ELEMENT);
/*
udanax-top.st:67809:IDRegion methodsFor: 'accessing'!
{Position} theOne
	myIncludesRest ifFalse:
		[myLocalIDs isEmpty ifTrue:
			[myImportedIDs ~~ NULL ifTrue:
				[^ID make: mySpace
					with: (myImportedIDs domain theOne cast: Sequence)
					with: ((myImportedIDs theOne cast: IntegerRegion) theOne cast: IntegerPos) asIntegerVar]]
		ifFalse:
			[myImportedIDs == NULL ifTrue:
				[^ID make: mySpace
					with: NULL
					with: (myLocalIDs theOne cast: IntegerPos) asIntegerVar]]].
	Heaper BLAST: #NotOneElement.
	^NULL!
*/
}
public int actualHashForEqual() {
	int result;
	result = getCategory().hashForEqual() ^ myLocalIDs.hashForEqual();
	if (mySpace != null) {
		result = result ^ mySpace.hashForEqual();
	}
	if (myImportedIDs != null) {
		result = result ^ myImportedIDs.hashForEqual();
	}
	if (myIncludesRest) {
		result = result ^ 65535;
	}
	return result;
/*
udanax-top.st:67827:IDRegion methodsFor: 'testing'!
{UInt32} actualHashForEqual
	| result {UInt32} |
	result := self getCategory hashForEqual bitXor: myLocalIDs hashForEqual.
	mySpace ~~ NULL ifTrue:
		[result := result bitXor: mySpace hashForEqual].
	myImportedIDs ~~ NULL ifTrue:
		[result := result bitXor: myImportedIDs hashForEqual].
	myIncludesRest ifTrue:
		[result := result bitXor: 65535].
	^result!
*/
}
public boolean hasMember(Position position) {
	if (position instanceof ID) {
		ID iD = (ID) position;
		Sequence be;
		IntegerRegion region;
		be = iD.fetchBackend();
		if (be == null) {
			return myLocalIDs.hasIntMember(iD.number());
		}
		else {
			if (myImportedIDs != null) {
				region = (IntegerRegion) (myImportedIDs.fetch(be));
			}
			else {
				region = null;
			}
			if (region == null) {
				return myIncludesRest;
			}
			else {
				return region.hasIntMember(iD.number());
			}
		}
	}
	return false;
/*
udanax-top.st:67839:IDRegion methodsFor: 'testing'!
{BooleanVar} hasMember: position {Position} 
	position cast: ID into: [ :iD | | be {Sequence | NULL} region {IntegerRegion | NULL} |
		be := iD fetchBackend.
		be == NULL
			ifTrue: [^myLocalIDs hasIntMember: iD number ]
			ifFalse:
				[myImportedIDs ~~ NULL
					ifTrue: [region := (myImportedIDs fetch: be) cast: IntegerRegion]
					ifFalse: [region := NULL].
				region == NULL
					ifTrue: [^myIncludesRest]
					ifFalse: [^region hasIntMember: iD number]]].
	^false "fodder"!
*/
}
public boolean isEmpty() {
	return ! myIncludesRest && (myImportedIDs == null && (myLocalIDs.isEmpty()));
/*
udanax-top.st:67854:IDRegion methodsFor: 'testing'!
{BooleanVar} isEmpty
	^myIncludesRest not
		and: [myImportedIDs == NULL
		and: [myLocalIDs isEmpty]]!
*/
}
public boolean isEqual(Heaper other) {
	if (other instanceof IDRegion) {
		IDRegion iDs = (IDRegion) other;
		if (mySpace == null) {
			if ( ! (iDs.fetchSpace() == null)) {
				return false;
			}
		}
		else {
			if ( ! (iDs.fetchSpace() != null && (iDs.fetchSpace().isEqual(mySpace)))) {
				return false;
			}
		}
		if (myIncludesRest == iDs.includesRest() && (myLocalIDs.isEqual(iDs.localIDs()))) {
			if (myImportedIDs == null) {
				return iDs.fetchImportedIDs() == null;
			}
			else {
				return iDs.fetchImportedIDs() != null && (iDs.fetchImportedIDs().isEqual(myImportedIDs));
			}
		}
		return false;
	}
	else {
		return false;
	}
/*
udanax-top.st:67860:IDRegion methodsFor: 'testing'!
{BooleanVar} isEqual: other {Heaper}
	other cast: IDRegion into: [ :iDs |
		mySpace == NULL
				ifTrue: [iDs fetchSpace == NULL ifFalse:[^false]]
				ifFalse: [(iDs fetchSpace ~~ NULL
					and: [iDs fetchSpace isEqual: mySpace]) ifFalse:[^false]].
		(myIncludesRest == iDs includesRest and: [myLocalIDs isEqual: iDs localIDs])
			ifTrue: [myImportedIDs == NULL
				ifTrue: [^ iDs fetchImportedIDs == NULL]
				ifFalse: [^ iDs fetchImportedIDs ~~ NULL
					and: [iDs fetchImportedIDs isEqual: myImportedIDs]]].
		^false]
	others:
		[^false].
	^false "fodder"!
*/
}
public boolean isFinite() {
	if ( ! ( ! myIncludesRest && (myLocalIDs.isFinite()))) {
		return false;
	}
	if (myImportedIDs != null) {
		Stepper stomper = myImportedIDs.stepper();
		for (; stomper.hasValue(); stomper.step()) {
			IntegerRegion numbers = (IntegerRegion) stomper.fetch();
			if (numbers == null) {
				continue ;
			}
			if ( ! (numbers.isFinite())) {
				return false;
			}
		}
		stomper.destroy();
	}
	return true;
/*
udanax-top.st:67877:IDRegion methodsFor: 'testing'!
{BooleanVar} isFinite
	(myIncludesRest not and: [myLocalIDs isFinite]) ifFalse: [^false].
	myImportedIDs ~~ NULL ifTrue:
		[myImportedIDs stepper forEach: [:numbers {IntegerRegion} |
			numbers isFinite ifFalse: [^false]]].
	^true!
*/
}
public boolean isFull() {
	return myImportedIDs == null && (myIncludesRest && (myLocalIDs.isFull()));
/*
udanax-top.st:67885:IDRegion methodsFor: 'testing'!
{BooleanVar} isFull
	^myImportedIDs == NULL
		and: [myIncludesRest
		and: [myLocalIDs isFull]]!
*/
}
public boolean isSimple() {
	if (myImportedIDs == null) {
		return myLocalIDs.isSimple();
	}
	if (myIncludesRest) {
		if ( ! (myLocalIDs.isSimple())) {
			return false;
		}
		Stepper stomper = myImportedIDs.stepper();
		for (; stomper.hasValue(); stomper.step()) {
			IntegerRegion iDs = (IntegerRegion) stomper.fetch();
			if (iDs == null) {
				continue ;
			}
			if ( ! (iDs.isSimple())) {
				return false;
			}
		}
		stomper.destroy();
		return true;
	}
	else {
		return myLocalIDs.isEmpty() && (myImportedIDs.count() == 1 && (((IntegerRegion) myImportedIDs.theOne()).isSimple()));
	}
/*
udanax-top.st:67891:IDRegion methodsFor: 'testing'!
{BooleanVar} isSimple
	myImportedIDs == NULL ifTrue:
		[^myLocalIDs isSimple].
	myIncludesRest ifTrue:
		[myLocalIDs isSimple ifFalse: [^false].
		myImportedIDs stepper forEach: [ :iDs {IntegerRegion} |
			iDs isSimple ifFalse: [^false]].
		^true]
	ifFalse:
		[^myLocalIDs isEmpty
			and: [myImportedIDs count = 1
			and: [(myImportedIDs theOne cast: IntegerRegion) isSimple]]]!
*/
}
public boolean isSubsetOf(XnRegion region) {
	if (region instanceof IDRegion) {
		IDRegion other = (IDRegion) region;
		if ( ! (myLocalIDs.isSubsetOf(other.localIDs()))) {
			return false;
		}
		if (myImportedIDs == null) {
			return ! myIncludesRest || (other.includesRest() && (other.fetchImportedIDs() == null));
		}
		if (other.fetchImportedIDs() == null) {
			return other.includesRest()
			/* since we know I have imported IDs */
			;
		}
		if (myIncludesRest) {
			if ( ! (other.includesRest() && (other.fetchImportedIDs().domain().isSubsetOf(myImportedIDs.domain())))) {
				return false;
			}
		}
		TableStepper stomper = myImportedIDs.stepper();
		for (; stomper.hasValue(); stomper.step()) {
			Sequence backend = (Sequence) stomper.position();
			IntegerRegion iDs = (IntegerRegion) stomper.fetch();
			if (iDs == null) {
				continue ;
			}
			IntegerRegion otherIDs;
			otherIDs = (IntegerRegion) (other.getImportedIDs().fetch(backend));
			if (otherIDs == null) {
				if ( ! (other.includesRest() || (iDs.isEmpty()))) {
					return false;
				}
			}
			else {
				if ( ! (iDs.isSubsetOf(otherIDs))) {
					return false;
				}
			}
		}
		stomper.destroy();
	}
	return true;
/*
udanax-top.st:67905:IDRegion methodsFor: 'testing'!
{BooleanVar} isSubsetOf: region {XnRegion}
	
	region cast: IDRegion into: [ :other |
		(myLocalIDs isSubsetOf: other localIDs)
			ifFalse: [^false].
		myImportedIDs == NULL ifTrue:
			[^myIncludesRest not
				or: [other includesRest
					and: [other fetchImportedIDs == NULL]]].
		other fetchImportedIDs == NULL ifTrue:
			[^other includesRest "since we know I have imported IDs"].
		myIncludesRest ifTrue:
			[(other includesRest
					and: [other fetchImportedIDs domain isSubsetOf: myImportedIDs domain])
				ifFalse: [^false]].
		myImportedIDs stepper forPositions:
			[ :backend {Sequence} :iDs {IntegerRegion} |
			| otherIDs {IntegerRegion | NULL} |
			otherIDs := (other getImportedIDs fetch: backend) cast: IntegerRegion.
			otherIDs == NULL
				ifTrue: [(other includesRest or: [iDs isEmpty])
					ifFalse: [^false]]
				ifFalse: [(iDs isSubsetOf: otherIDs)
					ifFalse: [^false]]]].
	^true!
*/
}
public Stepper actualStepper(OrderSpec order) {
	Someone.knownBug();
	/* might be enumerable in other cases */
	if ( ! (isFinite())) {
		throw new AboraRuntimeException(AboraRuntimeException.NOT_ENUMERABLE);
	}
	return new IDStepper(this);
/*
udanax-top.st:67933:IDRegion methodsFor: 'protected: enumerating'!
{Stepper of: Position} actualStepper: order {OrderSpec default: NULL} 
	self knownBug. "might be enumerable in other cases"
	self isFinite ifFalse:
		[Heaper BLAST: #NotEnumerable].
	^IDStepper create: self!
*/
}
public int count() {
	int result;
	if (myIncludesRest) {
		throw new AboraRuntimeException(AboraRuntimeException.MUST_BE_FINITE);
	}
	result = myLocalIDs.count();
	if (myImportedIDs != null) {
		Stepper stomper = myImportedIDs.stepper();
		for (; stomper.hasValue(); stomper.step()) {
			IntegerRegion iDs = (IntegerRegion) stomper.fetch();
			if (iDs == null) {
				continue ;
			}
			result = result + iDs.count();
		}
		stomper.destroy();
	}
	return result;
/*
udanax-top.st:67942:IDRegion methodsFor: 'enumerating'!
{IntegerVar} count
	| result {IntegerVar} |
	myIncludesRest ifTrue:
		[Heaper BLAST: #MustBeFinite].
	result := myLocalIDs count.
	myImportedIDs ~~ NULL ifTrue:
		[myImportedIDs stepper forEach: [ :iDs {IntegerRegion} |
			result := result + iDs count]].
	^result!
*/
}
public ScruSet distinctions() {
	SetAccumulator result;
	MuTable table;
	Ravi.thingToDo();
	/* consolidate duplicated code */
	result = SetAccumulator.make();
	if (myImportedIDs == null) {
		Stepper stomper = myLocalIDs.distinctions().stepper();
		for (; stomper.hasValue(); stomper.step()) {
			IntegerRegion local = (IntegerRegion) stomper.fetch();
			if (local == null) {
				continue ;
			}
			IDRegion region;
			region = IDRegion.make(mySpace, local, null, myIncludesRest);
			result.step(region);
		}
		stomper.destroy();
	}
	else {
		if (myIncludesRest) {
			Stepper stomper2 = myLocalIDs.distinctions().stepper();
			for (; stomper2.hasValue(); stomper2.step()) {
				IntegerRegion local1 = (IntegerRegion) stomper2.fetch();
				if (local1 == null) {
					continue ;
				}
				IDRegion region1;
				region1 = IDRegion.make(mySpace, local1, null, true);
				result.step(region1);
			}
			stomper2.destroy();
			TableStepper stomper3 = myImportedIDs.stepper();
			for (; stomper3.hasValue(); stomper3.step()) {
				Sequence backend = (Sequence) stomper3.position();
				IntegerRegion iDs = (IntegerRegion) stomper3.fetch();
				if (iDs == null) {
					continue ;
				}
				Stepper stomper4 = iDs.distinctions().stepper();
				for (; stomper4.hasValue(); stomper4.step()) {
					IntegerRegion importx = (IntegerRegion) stomper4.fetch();
					if (importx == null) {
						continue ;
					}
					IDRegion region2;
					table = MuTable.make(SequenceSpace.make());
					table.store(backend, importx);
					region2 = IDRegion.make(mySpace, IntegerRegion.allIntegers(), table.asImmuTable(), true);
					result.step(region2);
				}
				stomper4.destroy();
			}
			stomper3.destroy();
		}
		else {
			Sequence backend1;
			if ( ! (myLocalIDs.isEmpty() && (myImportedIDs.count() == 1))) {
				throw new AboraRuntimeException(AboraRuntimeException.MUST_BE_SIMPLE);
			}
			backend1 = (Sequence) myImportedIDs.domain().theOne();
			Stepper stomper5 = ((IntegerRegion) myImportedIDs.theOne()).distinctions().stepper();
			for (; stomper5.hasValue(); stomper5.step()) {
				Sequence importx1 = (Sequence) stomper5.fetch();
				if (importx1 == null) {
					continue ;
				}
				IDRegion region3;
				table = MuTable.make(SequenceSpace.make());
				table.store(backend1, importx1);
				region3 = IDRegion.make(mySpace, myLocalIDs, table.asImmuTable(), false);
				result.step(region3);
			}
			stomper5.destroy();
		}
	}
	return (ScruSet) result.value();
/*
udanax-top.st:67953:IDRegion methodsFor: 'enumerating'!
{ScruSet of: XnRegion} distinctions
	| result {SetAccumulator} table {MuTable of: Sequence} |
	Ravi thingToDo. "consolidate duplicated code"
	result := SetAccumulator make.
	myImportedIDs == NULL ifTrue:
		[myLocalIDs distinctions stepper forEach: [ :local {IntegerRegion} |
			| region {IDRegion} |
			region _ IDRegion make: mySpace
				with: local with: NULL with: myIncludesRest.
			result step: region]]
	ifFalse:
		[myIncludesRest ifTrue:
			[myLocalIDs distinctions stepper forEach:
				[ :local {IntegerRegion} |
				| region {IDRegion} |
				region _ IDRegion make: mySpace
									with: local with: NULL with: true.
				result step: region].
			myImportedIDs stepper forPositions:
				[ :backend {Sequence} :iDs {IntegerRegion} |
				iDs distinctions stepper forEach:
					[ :import {IntegerRegion} |
					| region {IDRegion} |
					table := MuTable make: SequenceSpace make.
					table at: backend store: import.
					region _ IDRegion make: mySpace
										with: IntegerRegion allIntegers
										with: table asImmuTable
										with: true.
					result step: region]]]
		ifFalse:
			[ | backend {Sequence} |
			(myLocalIDs isEmpty and: [myImportedIDs count = 1]) ifFalse:
				[Heaper BLAST: #MustBeSimple].
			backend := myImportedIDs domain theOne cast: Sequence.
			(myImportedIDs theOne cast: IntegerRegion) distinctions stepper forEach:
				[ :import {Sequence} |
				| region {IDRegion} |
				table := MuTable make: SequenceSpace make.
				table at: backend store: import.
				region _ IDRegion make: mySpace
						with: myLocalIDs
						with: table asImmuTable
						with: false.
				result step: region]]].
	^result value cast: ScruSet!
*/
}
public Stepper simpleRegions(OrderSpec order) {
	return new IDSimpleStepper(this);
/*
udanax-top.st:68001:IDRegion methodsFor: 'enumerating'!
{Stepper} simpleRegions: order {OrderSpec default: NULL} 
	^IDSimpleStepper create: self!
*/
}
/**
 * All backends which have generated IDs in this Region
 */
public SequenceRegion backends() {
	XnRegion result;
	if (myIncludesRest) {
		result = SequenceSpace.make().fullRegion();
		if ( ! (myLocalIDs.intersects(TheGlobalNumbers))) {
			result = result.without(Sequence.zero());
		}
		if ( ! (myLocalIDs.intersects(TheLocalNumbers))) {
			result = result.without(FeServer.identifier());
		}
		if (myImportedIDs != null) {
			TableStepper stomper = myImportedIDs.stepper();
			for (; stomper.hasValue(); stomper.step()) {
				Sequence backend = (Sequence) stomper.position();
				IntegerRegion iDs = (IntegerRegion) stomper.fetch();
				if (iDs == null) {
					continue ;
				}
				if (iDs.isEmpty()) {
					result = result.without(backend);
				}
			}
			stomper.destroy();
		}
		return (SequenceRegion) result;
	}
	else {
		result = SequenceSpace.make().emptyRegion();
		if (myLocalIDs.intersects(TheGlobalNumbers)) {
			result = result.with(Sequence.zero());
		}
		if (myLocalIDs.intersects(TheLocalNumbers)) {
			result = result.with(FeServer.identifier());
		}
		if (myImportedIDs != null) {
			result = result.unionWith(myImportedIDs.domain());
		}
		return (SequenceRegion) result;
	}
/*
udanax-top.st:68007:IDRegion methodsFor: 'private:'!
{SequenceRegion} backends
	"All backends which have generated IDs in this Region"
	
	| result {XnRegion} |
	myIncludesRest ifTrue:
		[result := SequenceSpace make fullRegion.
		(myLocalIDs intersects: TheGlobalNumbers) ifFalse:
			[result := result without: Sequence zero].
		(myLocalIDs intersects: TheLocalNumbers) ifFalse:
			[result := result without: FeServer identifier].
		myImportedIDs ~~ NULL ifTrue:
			[myImportedIDs stepper forPositions: [ :backend {Sequence} :iDs {IntegerRegion} |
				iDs isEmpty ifTrue:
					[result := result without: backend]]].
		^result cast: SequenceRegion]
	ifFalse:
		[result := SequenceSpace make emptyRegion.
		(myLocalIDs intersects: TheGlobalNumbers) ifTrue:
			[result := result with: Sequence zero].
		(myLocalIDs intersects: TheLocalNumbers) ifTrue:
			[result := result with: FeServer identifier].
		myImportedIDs ~~ NULL ifTrue:
			[result := result unionWith: myImportedIDs domain].
		^result cast: SequenceRegion]!
*/
}
/**
 * All backends which are non-empty and are explicitly listed. For IDSimpleStepper
 */
public XnRegion explicitBackends() {
	XnRegion result;
	result = SequenceSpace.make().emptyRegion();
	if (myLocalIDs.intersects(TheGlobalNumbers)) {
		result = result.with(Sequence.zero());
	}
	if (myLocalIDs.intersects(TheLocalNumbers)) {
		result = result.with(FeServer.identifier());
	}
	if (myImportedIDs != null) {
		if (myIncludesRest) {
			TableStepper stomper = myImportedIDs.stepper();
			for (; stomper.hasValue(); stomper.step()) {
				Sequence backend = (Sequence) stomper.position();
				IntegerRegion iDs = (IntegerRegion) stomper.fetch();
				if (iDs == null) {
					continue ;
				}
				if ( ! (iDs.isEmpty())) {
					result = result.with(backend);
				}
			}
			stomper.destroy();
		}
		else {
			result = result.unionWith(myImportedIDs.domain());
		}
	}
	return result;
/*
udanax-top.st:68032:IDRegion methodsFor: 'private:'!
{XnRegion of: Sequence} explicitBackends
	"All backends which are non-empty and are explicitly listed. For IDSimpleStepper"
	
	| result {XnRegion} |
	result := SequenceSpace make emptyRegion.
	(myLocalIDs intersects: TheGlobalNumbers) ifTrue:
		[result := result with: Sequence zero].
	(myLocalIDs intersects: TheLocalNumbers) ifTrue:
		[result := result with: FeServer identifier].
	myImportedIDs ~~ NULL ifTrue:
		[myIncludesRest ifTrue:
			[myImportedIDs stepper forPositions:
				[ :backend {Sequence} :iDs {IntegerRegion} |
				iDs isEmpty ifFalse:
					[result := result with: backend]]]
		ifFalse:
			[result := result unionWith: myImportedIDs domain]].
	^result!
*/
}
public ImmuTable fetchImportedIDs() {
	return myImportedIDs;
/*
udanax-top.st:68051:IDRegion methodsFor: 'private:'!
{ImmuTable | NULL of: Sequence and: IntegerRegion} fetchImportedIDs
	^myImportedIDs!
*/
}
/**
 * The region which covers material not in the explicitBackends list, or NULL if there is
 * none.
 */
public IDRegion fetchInexplicit() {
	MuTable result;
	ImmuTable actualResult;
	if ( ! (myIncludesRest)) {
		return null;
	}
	if (myImportedIDs == null) {
		result = null;
	}
	else {
		result = MuTable.make(SequenceSpace.make());
		TableStepper stomper = myImportedIDs.stepper();
		for (; stomper.hasValue(); stomper.step()) {
			Sequence backend = (Sequence) stomper.position();
			IntegerRegion iDs = (IntegerRegion) stomper.fetch();
			if (iDs == null) {
				continue ;
			}
			result.introduce(backend, IntegerRegion.make());
		}
		stomper.destroy();
	}
	if (result != null) {
		actualResult = result.asImmuTable();
	}
	else {
		actualResult = null;
	}
	return IDRegion.make(mySpace, IntegerRegion.make(), actualResult, true);
/*
udanax-top.st:68055:IDRegion methodsFor: 'private:'!
{IDRegion} fetchInexplicit
	"The region which covers material not in the explicitBackends list, or NULL if there is none."
	
	| result {MuTable | NULL} actualResult {ImmuTable | NULL} |
	myIncludesRest ifFalse:
		[^NULL].
	myImportedIDs == NULL ifTrue:
		[result := NULL]
	ifFalse:
		[result := MuTable make: SequenceSpace make.
		myImportedIDs stepper forPositions: [ :backend {Sequence} :iDs {IntegerRegion} |
			result at: backend introduce: IntegerRegion make]].
	result ~~ NULL ifTrue: [actualResult := result asImmuTable] ifFalse: [actualResult := NULL].
	^IDRegion make: mySpace
		with: IntegerRegion make
		with: actualResult
		with: true!
*/
}
public IDSpace fetchSpace() {
	return mySpace;
/*
udanax-top.st:68073:IDRegion methodsFor: 'private:'!
{IDSpace} fetchSpace
	^mySpace!
*/
}
public ImmuTable getImportedIDs() {
	if (myImportedIDs == null) {
		throw new AboraRuntimeException(AboraRuntimeException.INVALID_REQUEST);
	}
	return myImportedIDs;
/*
udanax-top.st:68077:IDRegion methodsFor: 'private:'!
{ImmuTable | NULL of: Sequence and: IntegerRegion} getImportedIDs
	myImportedIDs == NULL ifTrue:
		[Heaper BLAST: #InvalidRequest].
	^myImportedIDs!
*/
}
/**
 * The numbers of all IDs in this region that were generated by the given backend
 */
public XnRegion iDNumbersFrom(Sequence backend) {
	XnRegion result;
	if (backend.isEqual(Sequence.zero())) {
		return myLocalIDs.intersect(TheGlobalNumbers);
	}
	if (backend.isEqual(FeServer.identifier())) {
		return myLocalIDs.intersect(TheLocalNumbers);
	}
	if (myImportedIDs != null) {
		result = (XnRegion) (myImportedIDs.fetch(backend));
		if (result != null) {
			return result;
		}
	}
	if (myIncludesRest) {
		return TheLocalNumbers;
	}
	else {
		return IntegerSpace.make().emptyRegion();
	}
/*
udanax-top.st:68083:IDRegion methodsFor: 'private:'!
{XnRegion of: IntegerPos} iDNumbersFrom: backend {Sequence}
	"The numbers of all IDs in this region that were generated by the given backend"
	
	| result {XnRegion} |
	(backend isEqual: Sequence zero) ifTrue:
		[^myLocalIDs intersect: TheGlobalNumbers].
	(backend isEqual: FeServer identifier) ifTrue:
		[^myLocalIDs intersect: TheLocalNumbers].
	myImportedIDs ~~ NULL ifTrue:
		[result := (myImportedIDs fetch: backend) cast: XnRegion.
		result ~~ NULL ifTrue:
			[^result]].
	myIncludesRest
		ifTrue: [^TheLocalNumbers]
		ifFalse: [^IntegerSpace make emptyRegion]!
*/
}
public boolean includesRest() {
	return myIncludesRest;
/*
udanax-top.st:68099:IDRegion methodsFor: 'private:'!
{BooleanVar} includesRest
	^myIncludesRest!
*/
}
public IntegerRegion localIDs() {
	return myLocalIDs;
/*
udanax-top.st:68103:IDRegion methodsFor: 'private:'!
{IntegerRegion} localIDs
	^myLocalIDs!
*/
}
public XnRegion complement() {
	MuTable result;
	ImmuTable resTable;
	if (myImportedIDs == null) {
		result = null;
	}
	else {
		result = MuTable.make(SequenceSpace.make());
		TableStepper stomper = myImportedIDs.stepper();
		for (; stomper.hasValue(); stomper.step()) {
			Sequence backend = (Sequence) stomper.position();
			IntegerRegion iDs = (IntegerRegion) stomper.fetch();
			if (iDs == null) {
				continue ;
			}
			result.store(backend, (TheLocalNumbers.minus(iDs)));
		}
		stomper.destroy();
	}
	if (result == null) {
		resTable = null;
	}
	else {
		resTable = result.asImmuTable();
	}
	return IDRegion.make(mySpace, ((IntegerRegion) myLocalIDs.complement()), resTable, ! myIncludesRest);
/*
udanax-top.st:68109:IDRegion methodsFor: 'operations'!
{XnRegion} complement
	| result {MuTable of: Sequence and: IntegerRegion} resTable {ImmuTable} |
	myImportedIDs == NULL ifTrue:
		[result := NULL]
	ifFalse:
		[result := MuTable make: SequenceSpace make.
		myImportedIDs stepper forPositions:
			[ :backend {Sequence} :iDs {IntegerRegion} |
			result at: backend store: (TheLocalNumbers minus: iDs)]].
	result == NULL ifTrue: [resTable := NULL] ifFalse: [resTable := result asImmuTable].
	^IDRegion make: mySpace
		with: (myLocalIDs complement cast: IntegerRegion)
		with: resTable
		with: myIncludesRest not!
*/
}
public XnRegion intersect(XnRegion region) {
	ImmuTable resTable;
	if (region instanceof IDRegion) {
		IDRegion other = (IDRegion) region;
		MuTable result;
		if (myImportedIDs == null) {
			if (myIncludesRest && (other.fetchImportedIDs() != null)) {
				result = other.fetchImportedIDs().asMuTable();
			}
			else {
				result = null;
			}
		}
		else {
			if (other.fetchImportedIDs() == null) {
				if (other.includesRest()) {
					result = myImportedIDs.asMuTable();
				}
				else {
					result = null;
				}
			}
			else {
				result = MuTable.make(SequenceSpace.make());
				TableStepper stomper = myImportedIDs.stepper();
				for (; stomper.hasValue(); stomper.step()) {
					Sequence backend = (Sequence) stomper.position();
					IntegerRegion iDs = (IntegerRegion) stomper.fetch();
					if (iDs == null) {
						continue ;
					}
					IntegerRegion otherIDs;
					otherIDs = (IntegerRegion) (other.getImportedIDs().fetch(backend));
					if (otherIDs != null) {
						result.store(backend, (iDs.intersect(otherIDs)));
					}
					else {
						if (other.includesRest()) {
							result.store(backend, iDs);
						}
					}
				}
				stomper.destroy();
				if (myIncludesRest) {
					TableStepper stomper2 = other.getImportedIDs().stepper();
					for (; stomper2.hasValue(); stomper2.step()) {
						Sequence backend1 = (Sequence) stomper2.position();
						IntegerRegion otherIDs1 = (IntegerRegion) stomper2.fetch();
						if (otherIDs1 == null) {
							continue ;
						}
						IntegerRegion iDs1;
						iDs1 = (IntegerRegion) (myImportedIDs.fetch(backend1));
						if (iDs1 == null) {
							result.store(backend1, otherIDs1);
						}
					}
					stomper2.destroy();
				}
			}
		}
		if (result != null) {
			TableStepper stomper3 = result.stepper();
			for (; stomper3.hasValue(); stomper3.step()) {
				Sequence backend2 = (Sequence) stomper3.position();
				IntegerRegion iDs2 = (IntegerRegion) stomper3.fetch();
				if (iDs2 == null) {
					continue ;
				}
				boolean f;
				if (myIncludesRest && (other.includesRest())) {
					f = iDs2.isEqual(TheLocalNumbers);
				}
				else {
					f = iDs2.isEmpty();
				}
				if (f) {
					result.wipe(backend2);
				}
			}
			stomper3.destroy();
			if (result.isEmpty()) {
				result = null;
			}
		}
		if (result == null) {
			resTable = null;
		}
		else {
			resTable = result.asImmuTable();
		}
		return IDRegion.make(mySpace, ((IntegerRegion) (myLocalIDs.intersect(other.localIDs()))), resTable, (myIncludesRest && (other.includesRest())));
	}
	return null;
/*
udanax-top.st:68125:IDRegion methodsFor: 'operations'!
{XnRegion} intersect: region {XnRegion} 
	| resTable {ImmuTable} |
	region cast: IDRegion into: [ :other | | result {MuTable} |
		myImportedIDs == NULL ifTrue:
			[(myIncludesRest and: [other fetchImportedIDs ~~ NULL])
				ifTrue: [result := other fetchImportedIDs asMuTable]
				ifFalse: [result := NULL]]
		ifFalse:
			[other fetchImportedIDs == NULL ifTrue:
				[other includesRest
					ifTrue: [result := myImportedIDs asMuTable]
					ifFalse: [result := NULL]]
			ifFalse:
				[result := MuTable make: SequenceSpace make.
				myImportedIDs stepper forPositions:
					[ :backend {Sequence} :iDs {IntegerRegion} |
					| otherIDs {IntegerRegion} |
					otherIDs := (other getImportedIDs fetch: backend) cast: IntegerRegion.
					otherIDs ~~ NULL ifTrue:
						[result at: backend store: (iDs intersect: otherIDs)]
					ifFalse: [other includesRest ifTrue:
						[result at: backend store: iDs]]].
				myIncludesRest ifTrue:
					[other getImportedIDs stepper forPositions:
						[ :backend {Sequence} :otherIDs {IntegerRegion} |
						| iDs {IntegerRegion} |
						iDs := (myImportedIDs fetch: backend) cast: IntegerRegion.
						iDs == NULL ifTrue:
							[result at: backend store: otherIDs]]]]].
		result ~~ NULL ifTrue:
			[result stepper forPositions:
				[ :backend {Sequence} :iDs {IntegerRegion} | | f {BooleanVar} |
				(myIncludesRest and: [other includesRest])
					ifTrue: [f := iDs isEqual: TheLocalNumbers]
					ifFalse: [f := iDs isEmpty].
				f ifTrue: [result wipe: backend]].
			result isEmpty ifTrue:
				[result := NULL]].
		result == NULL ifTrue: [resTable := NULL] ifFalse: [resTable := result asImmuTable].
		^IDRegion make: mySpace
			with: ((myLocalIDs intersect: other localIDs) cast: IntegerRegion)
			with: resTable
			with: (myIncludesRest and: [other includesRest])].
	^NULL "fodder"!
*/
}
public XnRegion simpleUnion(XnRegion region) {
	if (region instanceof IDRegion) {
		IDRegion other = (IDRegion) region;
		Ravi.thingToDo();
		/* return fullRegion less often */
		if (myImportedIDs != null || (other.fetchImportedIDs() != null)) {
			return coordinateSpace().fullRegion();
		}
		return IDRegion.make(mySpace, ((IntegerRegion) (myLocalIDs.simpleUnion(other.localIDs()))), null, myIncludesRest);
	}
	return null;
/*
udanax-top.st:68170:IDRegion methodsFor: 'operations'!
{XnRegion} simpleUnion: region {XnRegion} 
	region cast: IDRegion into: [ :other |
		Ravi thingToDo. "return fullRegion less often"
		(myImportedIDs ~~ NULL or: [other fetchImportedIDs ~~ NULL])
			ifTrue: [^self coordinateSpace fullRegion].
		^IDRegion make: mySpace
			with: ((myLocalIDs simpleUnion: other localIDs) cast: IntegerRegion)
			with: NULL
			with: myIncludesRest].
	^NULL "fodder"!
*/
}
public XnRegion unionWith(XnRegion region) {
	ImmuTable resTable;
	if (region instanceof IDRegion) {
		IDRegion other = (IDRegion) region;
		MuTable result;
		if (myImportedIDs == null) {
			if (myIncludesRest || (other.fetchImportedIDs() == null)) {
				result = null;
			}
			else {
				result = other.fetchImportedIDs().asMuTable();
			}
		}
		else {
			if (other.fetchImportedIDs() == null) {
				if (other.includesRest()) {
					result = null;
				}
				else {
					result = myImportedIDs.asMuTable();
				}
			}
			else {
				result = MuTable.make(SequenceSpace.make());
				TableStepper stomper = myImportedIDs.stepper();
				for (; stomper.hasValue(); stomper.step()) {
					Sequence backend = (Sequence) stomper.position();
					IntegerRegion iDs = (IntegerRegion) stomper.fetch();
					if (iDs == null) {
						continue ;
					}
					IntegerRegion otherIDs;
					otherIDs = (IntegerRegion) (other.getImportedIDs().fetch(backend));
					if (otherIDs != null) {
						result.store(backend, (iDs.unionWith(otherIDs)));
					}
					else {
						if ( ! (other.includesRest())) {
							result.store(backend, iDs);
						}
					}
				}
				stomper.destroy();
				if ( ! (myIncludesRest)) {
					TableStepper stomper2 = other.getImportedIDs().stepper();
					for (; stomper2.hasValue(); stomper2.step()) {
						Sequence backend1 = (Sequence) stomper2.position();
						IntegerRegion otherIDs1 = (IntegerRegion) stomper2.fetch();
						if (otherIDs1 == null) {
							continue ;
						}
						IntegerRegion iDs1;
						iDs1 = (IntegerRegion) (myImportedIDs.fetch(backend1));
						if (iDs1 == null) {
							result.store(backend1, otherIDs1);
						}
					}
					stomper2.destroy();
				}
			}
		}
		if (result != null) {
			TableStepper stomper3 = result.stepper();
			for (; stomper3.hasValue(); stomper3.step()) {
				Sequence backend2 = (Sequence) stomper3.position();
				IntegerRegion iDs2 = (IntegerRegion) stomper3.fetch();
				if (iDs2 == null) {
					continue ;
				}
				boolean f;
				if (myIncludesRest || (other.includesRest())) {
					f = iDs2.isEqual(TheLocalNumbers);
				}
				else {
					f = iDs2.isEmpty();
				}
				if (f) {
					result.wipe(backend2);
				}
			}
			stomper3.destroy();
			if (result.isEmpty()) {
				result = null;
			}
		}
		if (result == null) {
			resTable = null;
		}
		else {
			resTable = result.asImmuTable();
		}
		return IDRegion.make(mySpace, ((IntegerRegion) (myLocalIDs.unionWith(other.localIDs()))), resTable, (myIncludesRest || (other.includesRest())));
	}
	return null;
/*
udanax-top.st:68182:IDRegion methodsFor: 'operations'!
{XnRegion} unionWith: region {XnRegion} 
	| resTable {ImmuTable} |
	region cast: IDRegion into: [ :other | | result {MuTable} |
		myImportedIDs == NULL ifTrue:
			[(myIncludesRest or: [other fetchImportedIDs == NULL])
				ifTrue: [result := NULL]
				ifFalse: [result := other fetchImportedIDs asMuTable]]
		ifFalse:
			[other fetchImportedIDs == NULL ifTrue:
				[other includesRest
					ifTrue: [result := NULL]
					ifFalse: [result := myImportedIDs asMuTable]]
			ifFalse:
				[result := MuTable make: SequenceSpace make.
				myImportedIDs stepper forPositions:
					[ :backend {Sequence} :iDs {IntegerRegion} |
					| otherIDs {IntegerRegion} |
					otherIDs := (other getImportedIDs fetch: backend) cast: IntegerRegion.
					otherIDs ~~ NULL ifTrue:
						[result at: backend store: (iDs unionWith: otherIDs)]
					ifFalse: [other includesRest ifFalse:
						[result at: backend store: iDs]]].
				myIncludesRest ifFalse:
					[other getImportedIDs stepper forPositions:
						[ :backend {Sequence} :otherIDs {IntegerRegion} |
						| iDs {IntegerRegion} |
						iDs := (myImportedIDs fetch: backend) cast: IntegerRegion.
						iDs == NULL ifTrue:
							[result at: backend store: otherIDs]]]]].
		result ~~ NULL ifTrue:
			[result stepper forPositions:
				[ :backend {Sequence} :iDs {IntegerRegion} | | f {BooleanVar} |
				(myIncludesRest or: [other includesRest])
					ifTrue: [f := iDs isEqual: TheLocalNumbers]
					ifFalse: [f := iDs isEmpty].
				f ifTrue: [result wipe: backend]].
			result isEmpty ifTrue:
				[result := NULL]].
		result == NULL ifTrue: [resTable := NULL] ifFalse: [resTable := result asImmuTable].
		^IDRegion make: mySpace
			with: ((myLocalIDs unionWith: other localIDs) cast: IntegerRegion)
			with: resTable
			with: (myIncludesRest or: [other includesRest])].
	^NULL "fodder"!
*/
}
public XnRegion with(Position pos) {
	ImmuTable resTable;
	IntegerRegion newLocalIDs;
	if (pos instanceof ID) {
		ID id = (ID) pos;
		MuTable result;
		if (myImportedIDs == null) {
			if (myIncludesRest || (id.fetchBackend() == null)) {
				result = null;
			}
			else {
				result = MuTable.make(id.fetchSpace());
				result.introduce(id.fetchBackend(), (IntegerRegion.make(id.number())));
			}
		}
		else {
			if (id.fetchBackend() == null) {
				result = myImportedIDs.asMuTable();
			}
			else {
				result = MuTable.make(SequenceSpace.make());
				TableStepper stomper = myImportedIDs.stepper();
				for (; stomper.hasValue(); stomper.step()) {
					Sequence backend = (Sequence) stomper.position();
					IntegerRegion iDs = (IntegerRegion) stomper.fetch();
					if (iDs == null) {
						continue ;
					}
					if (id.fetchBackend().isEqual(backend)) {
						result.store(backend, (iDs.withInt(id.number())));
					}
					else {
						result.store(backend, iDs);
					}
				}
				stomper.destroy();
			}
			if ( ! (myIncludesRest)) {
				result.store(id.fetchBackend(), (IntegerRegion.make(id.number())));
			}
		}
		if (result != null) {
			TableStepper stomper2 = result.stepper();
			for (; stomper2.hasValue(); stomper2.step()) {
				Sequence backend1 = (Sequence) stomper2.position();
				IntegerRegion iDs1 = (IntegerRegion) stomper2.fetch();
				if (iDs1 == null) {
					continue ;
				}
				boolean f;
				if (myIncludesRest) {
					f = iDs1.isEqual(TheLocalNumbers);
				}
				else {
					f = iDs1.isEmpty();
				}
				if (f) {
					result.wipe(backend1);
				}
			}
			stomper2.destroy();
			if (result.isEmpty()) {
				result = null;
			}
		}
		if (result == null) {
			resTable = null;
		}
		else {
			resTable = result.asImmuTable();
		}
		newLocalIDs = myLocalIDs;
		if (id.fetchBackend() == null) {
			newLocalIDs = (IntegerRegion) (newLocalIDs.withInt(id.number()));
		}
		return IDRegion.make(mySpace, newLocalIDs, resTable, myIncludesRest);
	}
	return null;
/*
udanax-top.st:68227:IDRegion methodsFor: 'operations'!
{XnRegion} with: pos {Position} 
	| resTable {ImmuTable} newLocalIDs {IntegerRegion} |
	pos cast: ID into: [ :id | | result {MuTable} |
		myImportedIDs == NULL ifTrue:
			[(myIncludesRest or: [id fetchBackend == NULL])
				ifTrue: [result := NULL]
				ifFalse: [result := MuTable make: id fetchSpace.
						result at: id fetchBackend introduce: (IntegerRegion make: id number)]]
		ifFalse:
			[id fetchBackend == NULL ifTrue:
				[result := myImportedIDs asMuTable]
			ifFalse:
				[result := MuTable make: SequenceSpace make.
				myImportedIDs stepper forPositions:
					[ :backend {Sequence} :iDs {IntegerRegion} |
					(id fetchBackend isEqual: backend)
						ifTrue: [result at: backend store: (iDs withInt: id number)]
						ifFalse: [result at: backend store: iDs]]].
				myIncludesRest ifFalse:
					[result at: id fetchBackend store: (IntegerRegion make: id number)]].
		result ~~ NULL ifTrue:
			[result stepper forPositions:
				[ :backend {Sequence} :iDs {IntegerRegion} | | f {BooleanVar} |
				myIncludesRest
					ifTrue: [f := iDs isEqual: TheLocalNumbers]
					ifFalse: [f := iDs isEmpty].
				f ifTrue: [result wipe: backend]].
			result isEmpty ifTrue:
				[result := NULL]].
		result == NULL ifTrue: [resTable := NULL] ifFalse: [resTable := result asImmuTable].
		newLocalIDs := myLocalIDs.
		id fetchBackend == NULL
			ifTrue: [newLocalIDs := (newLocalIDs withInt: id number) cast: IntegerRegion].
		^IDRegion make: mySpace
			with: newLocalIDs
			with: resTable
			with: myIncludesRest].
	^NULL "fodder"!
*/
}
public IDRegion(IDSpace space, IntegerRegion localIDs, ImmuTable importedIDs, boolean includesRest) {
	super();
	mySpace = space;
	myLocalIDs = localIDs;
	myImportedIDs = importedIDs;
	myIncludesRest = includesRest;
/*
udanax-top.st:68268:IDRegion methodsFor: 'protected: create'!
create: space {IDSpace | NULL}
	with: localIDs {IntegerRegion}
	with: importedIDs {ImmuTable | NULL of: Sequence and: IntegerRegion}
	with: includesRest {BooleanVar}
	
	super create.
	mySpace := space.
	myLocalIDs := localIDs.
	myImportedIDs := importedIDs.
	myIncludesRest := includesRest.!
*/
}
public void printOn(PrintWriter oo) {
	XnRegion iDs;
	oo.print("{");
	oo.print(((IDSpace) coordinateSpace()).identifier());
	oo.print(" |");
	iDs = myLocalIDs.intersect((IntegerRegion.before(0)));
	if ( ! (iDs.isEmpty())) {
		oo.print(" !");
		oo.print(iDs);
	}
	iDs = myLocalIDs.intersect((IntegerRegion.after(0)));
	if ( ! (iDs.isEmpty())) {
		oo.print(" ");
		oo.print(FeServer.identifier());
		oo.print(".");
		oo.print(iDs);
	}
	if ( ! (myImportedIDs == null)) {
		TableStepper stomper = myImportedIDs.stepper();
		for (; stomper.hasValue(); stomper.step()) {
			Sequence backend = (Sequence) stomper.position();
			IntegerRegion iDs1 = (IntegerRegion) stomper.fetch();
			if (iDs1 == null) {
				continue ;
			}
			oo.print(" ");
			oo.print(backend);
			oo.print(".");
			oo.print(iDs1);
		}
		stomper.destroy();
	}
	if (myIncludesRest) {
		oo.print(" ...{...} ");
	}
	oo.print("}");
/*
udanax-top.st:68281:IDRegion methodsFor: 'printing'!
{void} printOn: oo {ostream reference}
	| iDs {XnRegion} |
	oo << '{' << (self coordinateSpace cast: IDSpace) identifier << ' |'.
	iDs := myLocalIDs intersect: (IntegerRegion before: IntegerVarZero).
	iDs isEmpty ifFalse:
		[oo << ' !!' << iDs].
	iDs := myLocalIDs intersect: (IntegerRegion after: IntegerVarZero).
	iDs isEmpty ifFalse:
		[oo << ' ' << FeServer identifier << '.' << iDs].
	myImportedIDs == NULL ifFalse:
		[myImportedIDs stepper forPositions:
			[ :backend {Sequence} :iDs {IntegerRegion} |
			oo << ' ' << backend << '.' << iDs]].
	myIncludesRest ifTrue:
		[oo << ' ...{...} '].
	oo << '}'!
*/
}
/**
 * The identifiers of all the IDs in the region.
 * Note: This is only possible if the region is finite, and even then it takes up much more
 * space than the IDRegion. Use with caution. Tentative protocol.
 * @deprecated
 */
public SequenceRegion identifiers() {
	throw new PasseException();
/*
udanax-top.st:68301:IDRegion methodsFor: 'smalltalk: passe'!
{SequenceRegion} identifiers
	"The identifiers of all the IDs in the region.
	Note: This is only possible if the region is finite, and even then it takes up much more space than the IDRegion. Use with caution. Tentative protocol."
	
	self passe!
*/
}
public IDRegion(Rcvr receiver) {
	super(receiver);
	mySpace = (IDSpace) receiver.receiveHeaper();
	myLocalIDs = (IntegerRegion) receiver.receiveHeaper();
	myImportedIDs = (ImmuTable) receiver.receiveHeaper();
	myIncludesRest = receiver.receiveBooleanVar();
/*
udanax-top.st:68309:IDRegion methodsFor: 'generated:'!
create.Rcvr: receiver {Rcvr}
	super create.Rcvr: receiver.
	mySpace _ receiver receiveHeaper.
	myLocalIDs _ receiver receiveHeaper.
	myImportedIDs _ receiver receiveHeaper.
	myIncludesRest _ receiver receiveBooleanVar.!
*/
}
public void sendSelfTo(Xmtr xmtr) {
	super.sendSelfTo(xmtr);
	xmtr.sendHeaper(mySpace);
	xmtr.sendHeaper(myLocalIDs);
	xmtr.sendHeaper(myImportedIDs);
	xmtr.sendBooleanVar(myIncludesRest);
/*
udanax-top.st:68316:IDRegion methodsFor: 'generated:'!
{void} sendSelfTo: xmtr {Xmtr}
	super sendSelfTo: xmtr.
	xmtr sendHeaper: mySpace.
	xmtr sendHeaper: myLocalIDs.
	xmtr sendHeaper: myImportedIDs.
	xmtr sendBooleanVar: myIncludesRest.!
*/
}
/**
 * For IDSpace constructor only. Space had better be NULL if it's the global space
 */
public static IDRegion usingx(IDSpace space, IntegerRegion localIDs, ImmuTable importedIDs, boolean includesRest) {
	return new IDRegion(space, localIDs, importedIDs, includesRest);
/*
udanax-top.st:68338:IDRegion class methodsFor: 'private:'!
{IDRegion} usingx: space {IDSpace | NULL}
	with: localIDs {IntegerRegion}
	with: importedIDs {ImmuTable | NULL of: Sequence and: IntegerRegion}
	with: includesRest {BooleanVar}
	"For IDSpace constructor only. Space had better be NULL if it's the global space"
	
	^self create: space with: localIDs with: importedIDs with: includesRest.!
*/
}
public static void linkTimeNonInherited() {
	TheLocalNumbers = null;
	TheGlobalNumbers = null;
/*
udanax-top.st:68348:IDRegion class methodsFor: 'smalltalk: init'!
linkTimeNonInherited
	TheLocalNumbers := NULL.
	TheGlobalNumbers := NULL.!
*/
}
/**
 * @deprecated
 */
public static IDRegion make() {
	throw new PasseException();
/*
udanax-top.st:68355:IDRegion class methodsFor: 'smalltalk: passe'!
make
	self passe!
*/
}
/**
 * @deprecated
 */
public static void makeID(ID iD) {
	throw new PasseException();
/*
udanax-top.st:68359:IDRegion class methodsFor: 'smalltalk: passe'!
make.ID: iD {ID}
	
	self passe!
*/
}
/**
 * @deprecated
 */
public static IDRegion makeScruSet(ScruSet iDs) {
	throw new PasseException();
/*
udanax-top.st:68363:IDRegion class methodsFor: 'smalltalk: passe'!
make.ScruSet: iDs {ScruSet of: ID}
	self passe.
	^IDRegion create: false with: iDs asImmuSet!
*/
}
public static void initTimeNonInherited() {
	TheLocalNumbers = IntegerRegion.after(0);
	TheGlobalNumbers = IntegerRegion.before(0);
/*
udanax-top.st:68369:IDRegion class methodsFor: 'smalltalk: initialization'!
initTimeNonInherited
	self REQUIRES: PrimSpec.
	self REQUIRES: IntegerRegion.
	TheLocalNumbers := IntegerRegion after: IntegerVarZero.
	TheGlobalNumbers := IntegerRegion before: IntegerVarZero.!
*/
}
/**
 * {UInt8Array CLIENT} export
 */
public static void infostProtocol() {
/*
udanax-top.st:68378:IDRegion class methodsFor: 'smalltalk: system'!
info.stProtocol
"{UInt8Array CLIENT} export
"!
*/
}
/**
 * Essential. Take some information describing an IDRegion and create the IDRegion it was
 * exported from.
 */
public static IDRegion importx(PrimIntArray data) {
	SpecialistRcvr rcvr;
	Sequence spaceBackend;
	int spaceNumber;
	IDSpace space;
	IntegerRegion localIDs;
	int n;
	ImmuTable imported;
	boolean includesRest;
	rcvr = Binary2XcvrMaker.make().makeRcvr((TransferSpecialist.make(Cookbook.make())), (XnReadStream.make(((UInt8Array) data))));
	spaceBackend = ID.importSequence(rcvr);
	spaceNumber = rcvr.receiveIntegerVar();
	space = IDSpace.make(spaceBackend, spaceNumber);
	if (space.isEqual(((BeGrandMap) CurrentGrandMap.fluidGet()).globalIDSpace())) {
		space = null;
	}
	localIDs = ID.importIntegerRegion(rcvr);
	n = rcvr.receiveIntegerVar();
	if (n == 0) {
		imported = null;
	}
	else {
		MuTable table;
		table = MuTable.make(SequenceSpace.make());
		for (int i = 1; i <= n; i ++ ) {
			Sequence key;
			IntegerRegion value;
			key = ID.importSequence(rcvr);
			value = ID.importIntegerRegion(rcvr);
			table.introduce(key, value);
		}
		imported = table.asImmuTable();
	}
	includesRest = rcvr.receiveBooleanVar();
	return usingx(space, localIDs, imported, includesRest);
/*
udanax-top.st:68384:IDRegion class methodsFor: 'creation'!
{IDRegion CLIENT} import: data {PrimIntArray}
	"Essential. Take some information describing an IDRegion and create the IDRegion it was exported from."
	
	| rcvr {SpecialistRcvr} spaceBackend {Sequence} spaceNumber {IntegerVar}
	  space {IDSpace} localIDs {IntegerRegion} n {IntegerVar} imported {ImmuTable | NULL}
	  includesRest {BooleanVar} |
	rcvr := Binary2XcvrMaker make
		makeRcvr: (TransferSpecialist make: Cookbook make)
		with: (XnReadStream make: (data cast: UInt8Array)).
	spaceBackend := ID importSequence: rcvr.
	spaceNumber := rcvr receiveIntegerVar.
	space := IDSpace make: spaceBackend with: spaceNumber.
	(space isEqual: CurrentGrandMap fluidGet globalIDSpace) ifTrue:
		[space := NULL].
	localIDs := ID importIntegerRegion: rcvr.
	n := rcvr receiveIntegerVar.
	n == IntegerVarZero ifTrue:
		[imported := NULL]
	ifFalse:
		[ | table {MuTable} |
		table := MuTable make: SequenceSpace make.
		1 to: n do: [ :i {IntegerVar} | | key {Sequence} value {IntegerRegion} |
			key := ID importSequence: rcvr.
			value := ID importIntegerRegion: rcvr.
			table at: key introduce: value].
		imported := table asImmuTable].
	includesRest := rcvr receiveIntegerVar DOTasLong.
	^self usingx: space with: localIDs with: imported with: includesRest!
*/
}
public static IDRegion make(IDSpace space, IntegerRegion localIDs, ImmuTable importedIDs, boolean includesRest) {
	return new IDRegion(space, localIDs, importedIDs, includesRest);
/*
udanax-top.st:68413:IDRegion class methodsFor: 'creation'!
make: space {IDSpace | NULL}
	with: localIDs {IntegerRegion}
	with: importedIDs {ImmuTable | NULL of: Sequence and: IntegerRegion}
	with: includesRest {BooleanVar}
	^ self create: space with: localIDs with: importedIDs with: includesRest!
*/
}
public IDRegion() {
/*

Generated during transformation
*/
}
}
