/*
 * Abora-Gold
 * Part of the Abora hypertext project: http://www.abora.org
 * Copyright 2003, 2005 David G Jones
 * 
 * Translated from Udanax-Gold source code: http://www.udanax.com
 * Copyright 1979-1999 Udanax.com. All rights reserved
 */

package info.dgjones.abora.gold.traces;

import info.dgjones.abora.gold.collection.sets.ImmuSet;
import info.dgjones.abora.gold.java.AboraBlockSupport;
import info.dgjones.abora.gold.java.AboraSupport;
import info.dgjones.abora.gold.java.missing.smalltalk.Set;
import info.dgjones.abora.gold.primtab.PrimIndexTable;
import info.dgjones.abora.gold.traces.BoundedTrace;
import info.dgjones.abora.gold.traces.BranchDescription;
import info.dgjones.abora.gold.traces.DagBranch;
import info.dgjones.abora.gold.traces.TracePosition;
import info.dgjones.abora.gold.xcvr.Rcvr;
import info.dgjones.abora.gold.xcvr.Xmtr;
import info.dgjones.abora.gold.xpp.basic.Heaper;
import java.io.PrintWriter;

/**
 * Trace Positions represent absolute coordinates in a tree-ordered space.
 * The ent navigates to O-roots from H-roots in the northern direction using
 * TracePositions.  Refer to the Ent document for a description of the current
 * implementation.  TracePositions are generated by asking another tracePosition
 * for a newSuccesor.  The starting tracePosition is the initil TraceTree.  It
 * corresponds to branch 1, position 1.
 */
public class BoundedTrace extends TracePosition {

	protected BranchDescription myBranch;
	protected int myPosition;
/*
udanax-top.st:62923:
TracePosition subclass: #BoundedTrace
	instanceVariableNames: '
		myBranch {BranchDescription}
		myPosition {UInt32}'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Xanadu-Traces'!
*/
/*
udanax-top.st:62929:
BoundedTrace comment:
'Trace Positions represent absolute coordinates in a tree-ordered space.  
The ent navigates to O-roots from H-roots in the northern direction using 
TracePositions.  Refer to the Ent document for a description of the current 
implementation.  TracePositions are generated by asking another tracePosition
for a newSuccesor.  The starting tracePosition is the initil TraceTree.  It 
corresponds to branch 1, position 1.'!
*/
/*
udanax-top.st:62936:
(BoundedTrace getOrMakeCxxClassDescription)
	attributes: ((Set new) add: #CONCRETE; add: #COPY; yourself)!
*/
public static void initializeClassAttributes() {
	AboraSupport.findAboraClass(BoundedTrace.class).setAttributes( new Set().add("CONCRETE").add("COPY"));
/*

Generated during transformation: AddMethod
*/
}
/**
 * This isn't used now.  It might be later.  Hash
 * based on both the branch and position  This hash
 * uses a couple of arbitrary primes.
 */
public int actualHashForEqual() {
	return (myBranch.hashForEqual() + myPosition * 10993) & 134217727
	/* 2^27-1 */
	;
/*
udanax-top.st:62941:BoundedTrace methodsFor: 'testing'!
{UInt32} actualHashForEqual
	"This isn't used now.  It might be later.  Hash 
	 based on both the branch and position  This hash
	 uses a couple of arbitrary primes."
	^(myBranch hashForEqual + myPosition * 10993) bitAnd: 134217727 "2^27-1"!
*/
}
public boolean isEqual(Heaper another) {
	if (another instanceof BoundedTrace) {
		BoundedTrace bt = (BoundedTrace) another;
		return (myBranch.isEqual(bt.branch())) && (myPosition == bt.position());
	}
	else {
		return false;
	}
/*
udanax-top.st:62948:BoundedTrace methodsFor: 'testing'!
{BooleanVar} isEqual: another {Heaper}
	another
		cast: BoundedTrace into: [:bt |
			^(myBranch isEqual: bt branch)
			 and: [myPosition == bt position]]
		others: [^false].
	^false "fodder"!
*/
}
/**
 * Return true if the two positions are comparable and the receiver is
 * less than the argument. The argument is put in the cache so that
 * many comparisons IN THE SAME ORDER will occur very fast. This
 * could probably check for both tracePositions in the cache for speed
 * even when the arguments are swapped.
 */
public boolean isLE(TracePosition another) {
	return myBranch.doesInclude(myPosition, another);
/*
udanax-top.st:62957:BoundedTrace methodsFor: 'testing'!
{BooleanVar} isLE: another {TracePosition}
	"Return true if the two positions are comparable and the receiver is  
	less than the argument. The argument is put in the cache so that  
	many comparisons IN THE SAME ORDER will occur very fast. This  
	could probably check for both tracePositions in the cache for speed  
	even when the arguments are swapped."
	^myBranch does: myPosition include: another!
*/
}
/**
 * This should only be accessible in this module.
 */
public BranchDescription branch() {
	return myBranch;
/*
udanax-top.st:62968:BoundedTrace methodsFor: 'accessing'!
{BranchDescription} branch
	"This should only be accessible in this module."
	^myBranch!
*/
}
/**
 * Cache the nav-data for the receiver in navCache.
 */
public void cacheIn(PrimIndexTable navCache) {
	int oldValue;
	oldValue = navCache.fetch(myBranch);
	if (oldValue == -1) {
		navCache.store(myBranch, myPosition);
		myBranch.cacheRecur(navCache);
	}
	else {
		navCache.store(myBranch, (Math.max(oldValue, myPosition)));
	}
/*
udanax-top.st:62973:BoundedTrace methodsFor: 'accessing'!
{void} cacheIn: navCache {PrimIndexTable}
	"Cache the nav-data for the receiver in navCache."
	| oldValue {IntegerVar} | 
	oldValue _ navCache fetch: myBranch.
	oldValue == -1
		ifTrue: 
			[navCache at: myBranch store: myPosition.
			myBranch cacheRecur: navCache]
		ifFalse: 
			[navCache at: myBranch store: (oldValue max: myPosition)].!
*/
}
/**
 * Return a new successor to the receiver. The first successor is on the same
 * branch with a higher position. Further successors are alllocated in a
 * binary-tree fashion along a new branch.
 */
public TracePosition newSuccessor() {
	Someone.knownBug();
	/* This consistent count is upperbound over 12 runs of works test.
	It does not seem to be bound. */
	AboraBlockSupport.enterConsistent(14);
	try {
		return myBranch.createAfter(this);
	}
	finally {
		AboraBlockSupport.exitConsistent();
	}
/*
udanax-top.st:62985:BoundedTrace methodsFor: 'accessing'!
{TracePosition} newSuccessor
	"Return a new successor to the receiver. The first successor is on the same 
	branch with a higher position. Further successors are alllocated in a 
	binary-tree fashion along a new branch."
	self knownBug.
	"This consistent count is upperbound over 12 runs of works test.
	It does not seem to be bound."
	DiskManager consistent: 14 with:
		[^myBranch createAfter: self]!
*/
}
/**
 * Return a new tracePosition that is after both the receiver and tracePos.
 */
public TracePosition newSuccessorAfter(TracePosition trace) {
	Someone.knownBug();
	/* This consistent count is upperbound over 12 runs of works test.
	It does not seem to be bound. */
	AboraBlockSupport.enterConsistent(14);
	try {
		BranchDescription branch;
		branch = myBranch.makeBranch(this, trace);
		myBranch.installBranchAfter(branch, this);
		((BoundedTrace) trace).branch().installBranchAfter(branch, trace);
		return branch.nextPosition();
	}
	finally {
		AboraBlockSupport.exitConsistent();
	}
/*
udanax-top.st:62995:BoundedTrace methodsFor: 'accessing'!
{TracePosition} newSuccessorAfter: trace {TracePosition} 
	"Return a new tracePosition that is after both the receiver and tracePos."
	self knownBug.
	"This consistent count is upperbound over 12 runs of works test.
	It does not seem to be bound."
	DiskManager consistent: 14 with:
		[| branch {BranchDescription} |
		branch _ myBranch makeBranch: self with: trace.
		myBranch installBranch: branch after: self.
		(trace quickCast: BoundedTrace) branch installBranch: branch after: trace.
		^branch nextPosition]!
*/
}
/**
 * This should only be accessible in this module.
 */
public int position() {
	return myPosition;
/*
udanax-top.st:63008:BoundedTrace methodsFor: 'accessing'!
{UInt32} position
	"This should only be accessible in this module."
	^myPosition!
*/
}
/**
 * Return all the successors of the receiver.
 */
public ImmuSet successors() {
	return myBranch.successorsOf(this);
/*
udanax-top.st:63013:BoundedTrace methodsFor: 'accessing'!
{ImmuSet of: TracePosition} successors
	"Return all the successors of the receiver."
	^myBranch successorsOf: self!
*/
}
/*
udanax-top.st:63020:BoundedTrace methodsFor: 'smalltalk:'!
{void} inspect
	| seen |
	seen _ Set new.
	EntView openOn: (TreeBarnacle new
			buildOn: self
			gettingChildren:
				[:tracePos | 
				(seen includes: tracePos)
					ifTrue: [OrderedCollection new]
					ifFalse: [seen add: tracePos.
							tracePos successors asOrderedCollection]]
			gettingImage: [:tracePos | tracePos printString asDisplayText]
			at: 0 @ 0
			vertical: false
			separation: 10 @ 10)!
*/
public void printOn(PrintWriter aStream) {
	if (myPosition == 1 && (myBranch instanceof DagBranch)) {
		aStream.print(">");
	}
	aStream.print(myBranch);
	aStream.print(".");
	aStream.print(myPosition);
/*
udanax-top.st:63036:BoundedTrace methodsFor: 'smalltalk:'!
{void} printOn: aStream {Stream}
	(myPosition = 1 and: [myBranch isKindOf: DagBranch]) ifTrue: [aStream << '>'].
	aStream << myBranch << '.' << myPosition!
*/
}
public BoundedTrace(BranchDescription br, int pos) {
	super();
	myBranch = br;
	myPosition = pos;
/*
udanax-top.st:63042:BoundedTrace methodsFor: 'create'!
create: br {BranchDescription} with: pos {UInt32}
	super create.
	myBranch _ br.
	myPosition _ pos!
*/
}
public BoundedTrace(Rcvr receiver) {
	super(receiver);
	myBranch = (BranchDescription) receiver.receiveHeaper();
	myPosition = receiver.receiveUInt32();
/*
udanax-top.st:63049:BoundedTrace methodsFor: 'generated:'!
create.Rcvr: receiver {Rcvr}
	super create.Rcvr: receiver.
	myBranch _ receiver receiveHeaper.
	myPosition _ receiver receiveUInt32.!
*/
}
public void sendSelfTo(Xmtr xmtr) {
	super.sendSelfTo(xmtr);
	xmtr.sendHeaper(myBranch);
	xmtr.sendUInt32(myPosition);
/*
udanax-top.st:63054:BoundedTrace methodsFor: 'generated:'!
{void} sendSelfTo: xmtr {Xmtr}
	super sendSelfTo: xmtr.
	xmtr sendHeaper: myBranch.
	xmtr sendUInt32: myPosition.!
*/
}
public BoundedTrace() {
/*

Generated during transformation
*/
}
}
